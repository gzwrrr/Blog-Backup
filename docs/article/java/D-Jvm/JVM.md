---
title: "JVM"
shortTitle: "A-JVM"
description: "JVM"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "JVM"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM"
  description: "JVM"
  author:
    name: gzw
    email: 1627121193@qq.com
---




# JVM

JVM 的具体实现常见的有：

> 标 * 的是最常用的三大虚拟机

- *Hotspot（最常用，在各个平台都有涉及）
- *Jrocket（曾经号称最快，专注于服务器端，后来部分特性并入 Hotspot）
- *J9（IBM 自己的 VM 实现）
- TaobaoVM（Hotspot 定制版，大型厂商使用）
- LiquidVM（直接对接硬件）
- Zing（垃圾回收最快，回收算法之后被并入了 Hotspot）

注：Hotspot 访问对象采用的是直接指针访问（不是用句柄池）



## JVM 中的常量池

> 三种常量池

### 1.字符串常量池



### 2.class 常量池



### 3.运行时常量池





## 对象创建

### 创建方式

> 五种创建方式

|                方式                |       说明       |
| :--------------------------------: | :--------------: |
|           使用new关键字            |  调用了构造函数  |
|     使用Class的newInstance方法     |  调用了构造函数  |
| 使用Constructor类的newInstance方法 |  调用了构造函数  |
|           使用clone方法            | 没有调用构造函数 |
|            使用反序列化            | 没有调用构造函数 |


### 分配内存

> Java 堆是否规整是由所采用的垃圾收集器是否带有压缩整理功能决定的

**指针碰撞：**

- 前提：Java 堆内存是规整的，所有已用的空间都是紧挨着的
- 分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样就可以完成内存分配

**空闲列表：**

- 前提：Java 堆内存不是规整的，需要由虚拟机维护一个列表来记录哪些内存是可用的
- 分配内存时从列表中查询到足够大的内存就分配给对象，分配后更新列表





---





# JVM 架构模型

## Java 编译器

Java 编译器（hotspot）输入的指令流是基于「栈」的指令集架构，还有一种是基于「寄存器」的指令集架构

**基于栈的架构的特点：**

- 设计和实现简单，适用于资源受限的系统
- 避开了寄存器分配难题，可以直接使用零地址指令分配方式
- 指令流中的指令操作过程依赖于操作栈，指令集更小，编译器实现更容易
- 不需要硬件支持，可移植性更好，更好实现跨平台

**基于寄存器架构的特点：**

- 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主





## JVM 的生命周期

### 启动

- Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的
- 这个类是由虚拟机的具体实现指定的



### 执行

- 一个运行中的Java虚拟机有着一个清晰的任务∶执行Java程序
- 程序开始执行时他才运行，程序结束时他就停止
- 执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。





### 退出

- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作
- 除此之外，JNI（ Uava Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java虚拟机的退出情况



## 类加载器

- 负责从文件系统或网络中加载 Class 文件（Class 文件头有特定的标识）

- ClassLoader 只负责 Class 文件的加载，是否能执行由执行引擎决定
- 加载的类信息存放在「方法区」中
- Class 文件是存储在磁盘上的，而 JVM 中实例化对象是需要模板的，ClassLoader 就是将 Class 文件转换成二进制模板（DNA 元数据模板，在方法区中）
- 类加载分为三个过程：
  - 加载
  - 链接
  - 初始化

**加载 Class 文件的方式：**

- 从本地系统中直接加载
- 通过网络获取（Applet）

- 从 zip 压缩包中读取（例如读取 jar、war 包）
- 运行时动态生成（动态代理）
- 由其他文件生成（JSP）
- 从专有数据库中提取 Class 文件
- 从加密文件中获取（防止 Class 文件被反编译的保护措施）





### 加载

- 通过一个类的「全限定名」获取该类的二进制流文件
- 将这个字节流代表的「静态存储结构」转化为方法区的「运行时数据结构」
- 在内存中生成一个代表这个类的 `Java.lang.Class` 对象，作为方法区中这个类的各种数据的「访问入口」



### 链接

**验证：**

- 确保 Class 文件字节流信息符合当前虚拟机实现的要求，保证类加载安全的同时，不会危害到虚拟机自身的安全
- 主要包括四种验证：
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证

**准备：**

- 为类「分配内存」并设置该类的成员变量的「初始值为零值」（不包含用 final 修饰的 static 变量，因为 final 变量在编译的时候就分配了内存，在准备阶段会显示的初始化）
- 该阶段不会为实例变量初始化，类的变量会分配在方法区中，而实例变量会随实例对象一起分配在 Java 堆中

**解析：**

- 符号引用：用一组符号来描述所引用的目标，符号引用的「字面量形式」定义在 Class 文件中
- 直接引用：直接指向目标的指针、相对偏移量、间接定位到目标的句柄
- 解析就是将常量池中的「符号引用」转换为「直接引用」的过程
- 解析操作一般是 JVM 在执行完初始化操作后再执行的
- 解析动作主要针对「类」、「接口」、「字段」、「类方法」、「接口方法」、「方法类型」等。这些对应着常量池中的：`CONSTANT_CLass_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info` 等字段



### 初始化

- 初始化阶段执行类构造器方法：`<clinit>()` 过程
- 此方法不用定义，由 javac 编译器自动收集类中的所有「类变量」的赋值动作和「静态代码块」中的语句而合并来的（构造器方法是「虚拟机」视角下的 `<init>()` ）
- 构造器方法中指令按语句再源文件中出现的顺序执行
- 若该类具有父类，那么 JVM 会保证子类的 `<clinit>()` 方法执行前先执行完父类的 `<clinit>()`

- 虚拟机必须保证一个类的 `<clinit>()` 方法在多线程下被「同步加锁」



## 类加载器的分类

> 分为引导类加载器（Bootstrap ClassLoader，使用 C 语言实现）和自定义类加载器（User-Defined ClassLoader，使用 Java 实现）

- 自定义类加载器一般是由开发人员自定义的
- 但是 JVM 规范是将所有「派生于」ClassLoader 的类加载器都划分为自定义加载器
- 但是无论怎么划分，最常见的类加载器只有三种：
  - Bootstrap ClassLoader（加载 Java 核心 API 中的类，该类加载器无法获取）
  - Extension ClassLoader（加载 `java.ext.dirs` 和 `jre/lib/ext` 中的类）
  - System ClassLoader（如：Application ClassLoader，加载程序中的自定义类）
- 不同的类加载器之间的关系是「包含关系」

**自定义类加载器的作用：**

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露





### 双亲委派

- 一种任务委派模式，把请求交给父类处理
- JVM 对 Class 文件采用的是「按需加载」的加载方式，而在加载时就会使用双亲委派机制

**工作原理：**

- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是会把这个请求委托给父类的加载器去执行
- 如果父类加载器还存在其父类加载器，则会进一步向上委托，以此递归，请求最终会到达顶层的启动类加载器
- 如果父类加载器可以完成类加载任务，就返回成功，倘若无法完成才会让子加载器尝试自己加载

**双亲委派的优势：**

- 可以避免类重复加载
- 可以保护程序安全，防止核心 API 被随意篡改（沙箱安全机制）



### 类的主动/被动使用

**JVM 中两个 Class 对象是否为同一个类的两个必要条件：**

- 类的完整类名必须一致，包括包名
- 加载这个类的 ClassLoader 实例对象必须相同
- 因此，即使两个类对象来源于同一个 Class 文件，被同一个虚拟机加载，但是只要加载它们的 ClassLoader 实例不一样，那么这两个对象就不相等

**类加载器的引用：**

- JVM 必须知道一个类是由启动加载器加载的还是由用户加载器加载的
- 如果一个类是由用户加载器加载的，那么 JVM 会将这个类加载器的一个「引用」作为类型信息的一部分「保存在方法区中」
- 当解析到一个类到另一个类的引用的时候，JVM 需要保证这两个类的加载器是相同的

**主动使用类（7）：**

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射
- 初始化一个类的子类
- JVM 启动时被标明为启动类的类
- `java.lang.invoke.MethodHandle` 实例的解析结果

注：除了以上 7 中情况，其他使用类的方式都被看作是对类的「被动使用」，都不会导致「类的初始化」





# 运行时内存结构



在 Hotspot JVM 中，每个线程都与操作系统的本地线程直接映射

当一个 Java 线程准备好执行后，操作系统的一个本地线程也同时创建

Java 线程执行终止后，本地线程也会回收

操作系统负责把所有线程安排调度到任何一个可用的 CPU 上

一旦本地线程初始化成功，就会调用 Java 线程中的 `run`  方法



**Hotspot JVM 中的主要线程类型：**

- 虚拟机线程：需要 JVM 到达「安全点」才会出现的（需要保证堆不变化）。这种线程的执行类型包括：
  - stop-the-world 的垃圾收集
  - 线程栈收集
  - 线程挂起
  - 偏向锁撤销
- 周期任务线程：这种线程是时间周期时间的体现（如中断），它们一般用于周期性操作的调度执行
- GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供支持
- 编译线程：这种线程在运行时会将字节码编译成本地代码
- 信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理





## 程序计数器

> PC 计数器（Program Counter Register），源于 CPU 的寄存器，可以理解成「游标」

- PC 寄存器用来存储指向下一条指令的地址，即：将要执行的指令代码。之后由执行引擎取下一条指令
- 在内存中是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域
- JVM 规范中，每个线程都有自己的程序计数器，即线程私有的，生命周期与线程的生命周期保持一致
- 任何时间，一个线程都只有一个方法在执行，也就是「当前方法」
- 程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果执行的是 native 方法（对应本地方法栈），则是未指定值（undefined）
- 程序控制流的指示器，分治、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选择吓一条需要执行的字节码指令
- 程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域
- 对于程序计数器而言，不存在异常和垃圾回收的问题





## 方法区

> 常量信息是 Class 文件中常量池部分的内存映射

- 类加载信息
- 运行时常量池信息
- 字符串字面量
- 数字常量



## 虚拟机栈

> 栈是运行时的单位；堆是存储的单位

- 栈解决的是程序运行的问题，即程序如何执行，如何处理数据
- 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的「栈帧」，对应着一次次的 Java 方法调用，故虚拟机栈是线程私有的
- 生命周期和线程一致
- 主管 Java 程序的运行，保存方法的「局部变量」（8 种基本数据类型、对象的引用地址）、「部分结果」、「方法的调用和返回」
- 虚拟机栈的大小允许「动态」或者「固定不变」

**优点：**

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 对虚拟机栈的操作只有两个：
  - 每个方法执行都伴随着进栈
  - 每个方法执行结束后出战
- 对于栈而言，不存在垃圾回收问题

**可能的异常：**

- StackOverflowError：采用固定大小的虚拟机栈会在容量超出时抛出 StackOverflowError 异常
- OutOfMemoryError：如果虚拟机栈采用的是动态扩展的，并且在尝试扩展时无法申请到足够的内存时，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么虚拟机就会抛出 OutOfMemoryError 异常（OOM）

**虚拟机参数：**

- `-Xss`：调整虚拟机栈的大小



### 栈帧

**栈的存储单位：**

- 「栈帧」是栈的基本单位
- 在线程上正在执行的「每个方法」都有各自对应的一个「栈帧」
- 「栈帧」是一个内存区块，是一个数据集

**运行原理：**

- 栈的操作只有对栈帧的压栈和出栈
- 在一条活动的线程中，一个时间点上，只有一个活动的栈帧，即当前正在执行的方法的栈帧
- 与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在当前方法中调用了其他方法，对应的新的栈帧会被创建出来，称为新的当前栈
- 不同线程中所包含的栈帧是不允许存在互相引用的，即不可以引用另外一个线程的栈帧
- 正常的函数返回或者抛出异常都会导致栈帧被弹出

**栈帧的内部结构：**

- 局部变量表
- 操作数栈（表达式栈）
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址（正常退出或异常退出的定义）
- 附加信息



### 局部变量表

> 又称为「局部变量数组」或「本地变量表」

- 一个数字数组，主要用于存储「方法参数」和定义在方法内的「局部变量」，类型包括：8op3
  - 各类基本数据类型
  - 对象引用
  - 返回值类型
- 局部变量表是线程私有的，不存在数据安全问题
- 局部变量表所需的容量大小是在「编译器」确定下来的，保存在方法的 Code 属性的 `maximum local variables` 数据项中
- 方法运行期间是不会更改局部变量表的大小的
- 在栈帧中，与性能调优最密切的就是局部变量表
- 局部变量表中的变量也是重要的垃圾回收节点，只要被局部变量表中「直接」或「间接引用」的对象都不会被回收

**局部变量表的 slot：**

- 参数值总是存放在局部变量数组的 index=0 的位置，到数组长度 -1 的索引结束
- 局部变量表的最基本存储单元是 slot
- 局部变量表中存放编译器可知的各种「基本数据类型」、引用类型、返回值类型的变量
- 在局部变量表中，32 位以内的类型只占用一个 slot，64 位的类型占用两个 slot
  - byte、short、char、boolean 在存储前都被转换成 int
  - long、double 占据两个 slot

- JVM 会为局部变量表中的每一个 slot 分配一个「访问索引」。通过这个索引可以访问到对应的局部变量值
- 当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将「按照顺序被复制」到局部变量表中的每一个 slot 上
- 如果需要访问局部变量表中的一个 64 位的局部变量值时，只需要使用一个索引即可（起始索引）
- 如果当前帧是由「构造方法」或者「实例方法」创建的，那么该对象引用 this 将会存储在 「index 为 0 的 slot 处」，其余的参数按照参数表顺序继续排列；因此静态代码块中不允许使用 this
- 栈帧中的局部变量表中的 slot 是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就可能复用过期的局部变量的槽位，从而达到节省资源的目的



### 操作数栈

- 在方法执行过程中，根据字节码指令，可能会往栈中写入数据和提取数，例如执行复制、交换、求和等操作
- 主要用于保存计算过程中的「中间结果」，同时作为计算过程中变量的「临时存储空间」
- 操作数栈是 JVM 执行引擎的一个工作区，当一个新的栈帧创建出来后，其操作数栈是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需要的最大深度在编译器就定义好了，保存在方法的 Code 属性中，为 max_stack 的值
- 操作数栈中的任何一个元可以是任意的 Java 数据类型
  - 32 位的类型占用一个栈单位深度
  - 64 位的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式进行数据访问，而是只能通过标准的入栈出栈操作来完成一次数据访问
- 如果被调用的方法带有「返回值」，那么其返回值会被压入当前栈帧的「操作数栈」中，并更新 PC 寄存器中下一条需要执行的字节码指令
- 操作数栈中的元素的「数据类型」必须与「字节码指令的序列」严格匹配，这由编译器在编译期间进行验证，同时在类加载阶段的类校验阶段的数据流分析阶段再次验证
- JVM 的解释引擎是基于栈的执行引擎，其中的栈指的就是「操作数栈」



### 动态链接

> 或称为：运行时常量池的方法引用

- 每一个栈帧内部都包含一个指向「运行时常量池」中「该栈帧所属方法的引用」，包含整个引用的目的就是支持当前方法的代码能够「动态链接」
- 在 Java 源文件被编译到字节码文件时，所有的「变量」和「方法引用」都作为「符号引用」保存在 Class 文件的常量池里，当建立动态链接后，就将「符号引用」转化为调用方法的直接引用



### 方法的调用

> 将符号引用转化为调用方法的直接引用与方法的「绑定机制」有关

**静态链接：**当一个字节码文件被转载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时保持不变，那么这种情况下就将转换为直接引用的过程称为「静态链接」

**动态链接：**被调用的方法在编译期无法确定下来，只能在程序运行期间转换为直接引用，所以这种转换过程具有动态性，称之为「动态链接」

**绑定：**绑定是一个「字段」、「方法」、「类」在符号引用被替换为直接引用的过程，这个过程仅仅发生一次

- 早期绑定：指被调用的「目标方法」在编译期可知，可以直接将方法与所属的类型进行绑定，这样就可以明确被调用的方法是哪一个，即可以使用「静态链接」
- 晚期绑定：被调用的方法在编译期无法确定下来，只能根据运行期实际的类型绑定相关的方法，即使用「动态链接」

**虚方法和非虚方法：**

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，那么这样的方法就称为非虚方法；静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法；除此之外的方法称为虚方法
- 虚拟机中提供了一下几条方法调用指令：
  - `invokestatic`：调用静态方法，解析阶段确定唯一方法版本
  - `invokespecial`：调用 `<init>` 方法、私有方法以及父类方法，解析阶段确定唯一版本
  - `invokevirtual`：调用所有虚方法
  - `invokeinterface`：调用接口方法
  - `invokeddynamic`：动态解析出需要调用的方法后执行（Java 7 之后才增加的指令）

- 上述前四条指令固化在虚拟机内部，方法的调用执行不可以认为干预，其中前两条指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法；最后一条指令则支持用户确定方法版本

**方法重写的本质：**

- 找到操作数栈顶的第一个元素所执行的对象的「实际类型」，记作 C
- 如果在过程结束时，不通过类型 C 中找到与常量中的描述符合的简单名称相符的方法，就会进行「访问权限校验」，如果通过则返回这个方法的直接引用，找不到就会抛出 `IllegaAccessError` 异常
- 在当前类中找不到则会按照继承关系从下往上依次对 C 的各个父类进行上述步骤的搜索和验证
- 如果始终都没有找到合适的方法，则会抛出 `AbstractMethodError` 异常

**虚方法表：**

- 在面向对象编程中，会频繁地使用到动态分配（`invokeddynamic`），如果每次分派过程中都需要重新在类的方法元数据中搜索合适的目标，那么就会影响执行效率，为了提高性能，JVM 采用在「方法区」建立一个虚方法表来实现（非虚方法不会在其中出现），内部是使用「索引表」来代替查找
- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 虚方法表的创建实际是，在类加载的「链接阶段」被创建并初始化的，类变量初始值准备完成后，JVM 会把该类的「方法表」也初始化完毕

**方法返回地址：**

- 存放调用该方法的 PC 寄存器的值（即下一条需要执行的指令的地址）
- 一个方法的结束有两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 但是无论通过哪种方法退出，之后都会返回到该方法被调用的位置。正常退出时，调用者的 PC 寄存器的值作为返回地址；通过异常退出，返回地址是要通过「异常处理表」来确定，栈帧中一般不会保存这部分信息
  - 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），就会有返回值传递给上层的方法调用者
  - 异常完成出口：在方法执行过程中遇到了异常，并且这个异常没有在方法内进行处理，也即只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
- 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的「实际数据类型」而定
- 在字节码指令中，返回指令包含 `ireturn` （当返回值是 `boolean`、`byte`、`char`、`short`、`int`）、`lreturn`、`freturn`、`dreturn`、`areturn`。另外还有一个 `return` 指令供声明为 void 的方法、实例初始化方法、类和接口的初始方法使用
- 本质上来说，方法的退出就是当前「栈帧出栈」的过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置 PC 寄存器值等，这样才能让调用者方法继续执行下去；正常完成和异常完成的区别在于：通过异常完成退出的方法不会给他的上层调用者产生任何的返回值

**附加信息：**

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息



### 常见面试题

1. 举例栈溢出的情况？ —— OOM，通过 -Xss 设置栈的大小
2. 调整栈大小，就能保证不出现栈溢出？—— 不能保证一定不溢出，例如对于死循环只能延缓溢出的时间
3. 分配的栈内存越大越好吗？—— 不是，可能会导致其他结构的内存空间减少，导致性能下降
4. 垃圾回收是否涉及到虚拟机栈？—— 本地方法栈和虚拟机栈都不会涉及到虚拟机栈
5. 方法中定义的局部变量是否线程安全？—— 不一定，如果是多线程或者方法参数逃逸则可能线程不安全，即如果变量能在内部消亡则是安全的





## 本地方法栈

【简介】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

一个「本地方法」就是一个 Java 调用非 Java 代码的接口（使用 native 关键字修饰）

本地方法的实现由「非 Java 语言」实现，比如 C，但是这个特征不是  Java 特有的，例如 C++ 中也可以调用 C 的函数

在定义一个本地方法时，并不提供实现体，类似定义 Java 中的接口，因为其实现体式由其他语言实现的

需要提高程序性能时就可以考虑使用本地方法；或者需要与 Java 的外部环境交互时也是使用本地方法（本地方法存在的主要原因）

但是目前本地方法已经很少使用了，除非是要编写与硬件相关的应用

【相关】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

本地方法栈也是「线程私有的」，允许被实现成固定或者可动态扩展的内存大小（在内存溢出方面和虚拟机栈一样）

本地方法的具体做法就是使用 native 关键字表示本地方法，这样就会将该方法登记到本地方法栈中，之后会在 Execution Engine 执行时加载本地方法

【进阶】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

当某个线程调用一个本地方法时，它就进入到了一个全新的不受虚拟机限制的世界，此时它与虚拟机拥有相同的全新啊

本地方法可以通过本地方法接口来访问「虚拟机内部的运行时数据区」，甚至可以直接使用本地处理器中的「寄存器」，也可以直接从本地内存的堆中分配任意数量的「内存」

但是注意，并不是所有 JVM 都支持本地方法。不过在 Hotspot JVM 中是直接将本地方法栈和虚拟机栈合二为一了







# 堆

## 概述

一个 JVM 实例只存在一个「堆内存」，堆也是 Java 内存管理的核心区域

Java 堆区在 JVM 启动时即被创建，此时空间大小也就确定了，这是 JVM 管理的最大的一块内存空间（内存大小是可以调节的）

堆可以处于物理上的「不连续」的内存空间，但在「逻辑上」应该被视为「连续的」

所有的线程共享 Java 堆，在这里还可以划分「线程私有」的「缓冲区」（TLAB）

几乎所有的「对象实例」以及「数组」运行时都应该分配在堆上

数组和对象可能永远不会存储在栈上，因为栈帧中保存的是引用，这个引用是指向堆的

在方法结束后，堆中的对象不会被立刻移除，而是在之后的垃圾回收时移除；而堆是 GC 执行垃圾回收的重点区域



## 内存细分

现代垃圾收集器（GC）大部分都基于「分代收集理论」设计，堆空间可以细分为：

Java 7 之前堆内存逻辑上分为三部分：新生代（又分为伊甸园区和存活区） + 老年代 + 永久代（这个在方法区）

Java 8 之后堆内存逻辑上分为三部分：新生代（又分为伊甸园区和存活区） + 老年代 + 元空间（这个在方法区）

新生代中实际的内存应该是伊甸园区加上两个存活区中的其中一个（因为存活区是基于复制的，所以其中一个必须为空，其中的内存不能使用）

【内存参数设置】

可以通过 `-Xms` 指令设置堆空间的起始内存，等价于 `-XX:InitialHeapSize`

可以通过 `-Xmx` 指令设置堆空间的最大内存，等价于 `-XX:MaxHeapSize`

一旦堆区中的内存大小超过 `-Xmx` 所指定的最大内存时，就会抛出 `OutOfMemoryError` 异常，即 OOM

通常设置时会将 `-Xmx` 和 `-Xms` 两个参数配置相同的值，目的是为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能



## 年轻代与老年代

存储在 JVM 的 Java 对象可以被划分为两类：

- 生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 生命周期非常长，极端情况下可以与 JVM 的生命周期保持一致

年轻代中又可以划分为三个空间：

1. 伊甸园空间
2. Survivor0（也称为 from 区）
3. Survivor1（也称为 to 区）

注：两个存活区的大小是一样的

配置新生代与老年代在堆结构的占比：默认 `-XX:NewRatio=2`，表示新生代占 1，老年代占 2

默认情况下，新生区中的伊甸园区占 8 份，两个存活区各占 1 份，可以通过 `-XX:SurvivorRatio` 调整这个比例（此处需要使用 `-XX:-UseAdaptiveSizePolicy` 关闭自适应的内存分配策略）

绝大部分的 Java 对象的「销毁」都在「新生代」中进行，可以使用  `-Xmn` 来设置新生代最大内存大小（这个参数一般使用默认值就行）

【垃圾回收】

当伊甸园中的空间耗尽时，会进行 `YGC/MinorGC` 垃圾回收，没有引用的对象会被回收，被引用的对象 `age` 会增加进入存活区；下一轮垃圾回收时，同样也是上述过程，但是此时存活的对象需要移向第二块存活区，也就是说存活区必须始终有一块是空的

当一个对象的 `age` 大于 15 时会晋升进入老年代，此后不需要再关注 `age`，何时进入老年代可以使用 `-XX:MaxTenuringThreashold=<N>`（参数默认是 15），进入了老年代中的对象一般都很难再被垃圾回收 

此处需要特别注意，上述提到的过程，只有当伊甸园区的空间耗尽时才会进行 GC，但是当存活区空间耗尽时并不会触发 GC，此时的回收逻辑是，等待伊甸园区再次空间耗尽，然后连同存活区一起进行 GC，即存活区是「被动回收」的，此时清除哪些对象也有特定规则（`age` 未到达 15 也有可能直接进入老年代，甚至一创建就进入老年代也是有可能的）

总结：GC 频繁发生在新生区，很少发生在养老区，几乎不发生在永久区；存活区是采用「复制后交换」的方式交替进行的，必须始终保持有一个存活区是空的，且当存活区满时只能被动进行 GC

【老年代 GC】

老年代 Major GC/FullGC 触发机制：

指发生在老年代的 GC，对象从老年代消失时，我们说 MajorGC 或 FullGC发生了

出现了 MajorGC，经常会伴随至少一次的 MinorGC (但非绝对的，在 Parallel cavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）

也就是在老年代空间不足时，会先尝试触发 MinorGC。如果之后空间还不足，则触发 MajorGC

MajorGC 的速度一般会比 MinorGC 慢 10 倍以上，STW 的时间更长

如果 MajorGC 后，内存还不足，就报 OOM 了。

【FullFC】

触发条件如下：

1. 调用 `System.gc()` 时，系统建议执行 FullGC，但时不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过 MinorGC 后进入老年代的平均大小大于老年代的可用内存
5. 存活区转移复制对象后整体大小大于存活区的总大小，就会将对象转存到老年代，但是老年代的大小也不能放下这些对象时也会触发

FullGC 是在开发或者调优过程中要尽量避免的，这样线程暂停的时间会短一些

【相关概念】

GC 主要分为两大类：

- 部分收集：
  - MinorGC（新生代收集）
  - MajorGC（老年代收集，目前只有 CMS GC 才有单独收集老年代的行为）
  - MixedGC（混合收集，收集整个新生代以及部分老年代，目前只有 G1 GC 有这种行为）
- 整堆收集：
  - FullGC（收集整个堆和方法区）

调优重点关注的是后两者，因为耗费的时间非常多

注意：很多时候 MajorGC 和 FullGC 会混合使用，需要具体分辨是老年代收集还是整堆收集

【内存分配策略】

针对不同年龄段的对象的分配原则：

- 优先分配到伊甸园区
- 大对象直接分配到老年代（避免程序中出现过多的大对象）
- 长期存活的对象分配到老年代
- 动态对象年龄判断：如果幸存者区中相同年龄的所有对象大小总和大于幸存者区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄
- 空间分配担保：`-XX:HandlePromotionFailure`，即当 GC 完成后幸存者区还有大量对象存活，那么就需要老年代担保，分出一部分空间

堆空间分代思想

内存分配策略

对象分配内存：TLAB

堆空间的参数设置

探讨堆是否是对象分配的唯一选择



## TLAB 对象分配过程

- 堆区是线程共享区域，任何线程都可以访问到堆中的共享数据
- 对象实例在 JVM 中创建是非常频繁的，并发环境下从堆区划分内存空间是「线程不安全」的
- 为了避免多个线程操作同一个地址，需要使用加锁等机制，但是这会影响分配速度 

**TLAB：**

- 从内存模型而不是垃圾收集的角度，对伊甸园区进行划分，JVM 为每个线程分配一个「私有缓存区域」
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的费县册亨安全问题，同时还能提升内存分配的吞吐量，因此可以把这种分配策略称为「快速分配策略」
- 所有 OpenJDK 衍生出来的 JVM 都使用了 TLAB
- 不是所有的对象实例都能够在 TLAB 中成功分配内存，但是 JVM 会将 TLAB 作为内存分配的首选
- 可以通过选项 `-XX:UseTLAB` 设置是否开启 TLAB 空间（默认是开启的）
- 默认情况下 TLAB 的内存空间是非常下的，仅仅占了伊甸园区空间的 1%，可以通过选项 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用的伊甸园区的百分比大小
- 一旦对象在 TLAB 空间分配内存失败， JVM 就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在伊甸园区中直接分配内存



## 堆常用参数总结

| 序号 | 参数                        | 说明                                                         |
| ---- | --------------------------- | ------------------------------------------------------------ |
| 1    | -XX:+PrintFlagsInitial      | 查看所有的参数的默认初始值                                   |
| 2    | -XX:+PrintFlagsInitial      | 查看所有的参数的默认初始值<br/>                              |
| 3    | -XX:+PrintFlagsFinal        | 查看所有的参数的最终值（可能会存在修改，不再是初始值）<br/>  |
| 4    | -Xms                        | 初始堆空间内存（默认为物理内存的1/64）<br/>                  |
| 5    | -Xmx                        | 最大堆空间内存（默认为物理内存的1/4）<br/>                   |
| 6    | -Xmn                        | 设置新生代的大小。（初始值及最大值）<br/>                    |
| 7    | -XX:NewRatio                | 配置新生代与老年代在堆结构的占比<br/>                        |
| 8    | -XX:SurvivorRatio           | 设置新生代中Eden和S0/S1空间的比例<br/>                       |
| 9    | -XX:MaxTenuringThreshold    | 设置新生代垃圾的最大年龄<br/>                                |
| 10   | -XX:+PrintGCDetails         | 输出详细的GC处理日志<br/>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc<br/> |
| 11   | -XX:HandlePromotionFalilure | 是否设置空间分配担保                                         |

对于最后一个参数，即空间对象担保：

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间：

- 如果大于，则此次Minor GC是安全的

- 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允担保失败。 

- - 如果`HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 

- - - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；

- - - 如果小于，则改为进行一次Full GC。

- - 如果`HandlePromotionFailure=false`，则改为进行一次Full Gc。

在 JDK6 Update24 （JDK 7）之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 FullGC。



## 堆的补充 -- 分配优化

堆不是分配对象存储的唯一选择（但是全部分配到堆上在最后被验证是较好的），《深入理解 JVM》中曾表述：

> 随着「JIT 编译期的发展」与「逃逸分析技术」逐渐成熟，「栈上分配」、「标量替换优化技术」将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了

如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术

此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。



### 逃逸分析 -- 简介

如何将堆上的对象分配到栈，需要使用逃逸分析手段

这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。

- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

**参数设置：**

在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析

如果使用的是较早的版本，开发人员则可以通过：

- 选项 `-XX:+DoEscapeAnalysis` 显式开启逃逸分析

- 通过选项 `-XX:+PrintEscapeAnalysis` 查看逃逸分析的筛选结果

**结论**：开发中能使用局部变量的，就不要使用在方法外定义



### 逃逸分析 -- 代码优化

使用逃逸分析，编译器可以对代码做如下优化：

1. 「栈上分配」：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配

2. 「同步省略」：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步

3. 「分离对象或标量替换」：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU 寄存器中

**栈上分配：**

- JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了

- **常见的栈上分配的场景**：在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递

**同步省略：**

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。

- 在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除

**标量替换：**

- 标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量
- 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
- 在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换

**标量替换参数设置：**

- 参数 `-XX:EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配到栈上。

- 标量替换参数设置示例：

  ```shell
  -server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations
  ```

- 这里设置参数如下：

  - 参数`-server`：启动Server模式，因为在server模式下，才可以启用逃逸分析。

  - 参数`-XX:+DoEscapeAnalysis`：启用逃逸分析

  - 参数`-Xmx10m`：指定了堆空间最大为10MB

  - 参数`-XX:+PrintGC`：将打印Gc日志

  - 参数`-XX:+EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配



### 逃逸分析 -- 小结

关于逃逸分析的论文在1999年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟

其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。

一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了

虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段

注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。

目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。



## 堆的总结

年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。

老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为 MinorGC。

当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGC 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。









# 补充

栈管运行、堆管存储

Jconsole

jps 查看所有当前进程

`jstat -gc 进程号`

jvisualvm 图形化监控界面

`-XX:+PrintGCDetails` 指令加载启动时可以查看 GC 相关的指标

`jinfo -flag 指令 进程号` 查看某个进程某个启动指令的状况

JDK 内置了许多命令行工具，它们可用来获取目标 JVM 不同方面、不同层次的信息。

- jinfo - 用于实时查看和调整目标 JVM 的各项参数。
- jstack - 用于获取目标 Java 进程内的线程堆栈信息，可用来检测死锁、定位死循环等。
- jmap - 用于获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。
- jstat - 一款轻量级多功能监控工具，可用于获取目标 Java 进程的类加载、JIT 编译、垃圾收集、内存使用等信息。
- jcmd - 相比 jstat 功能更为全面的工具，可用于获取目标 Java 进程的性能统计、JFR、内存使用、垃圾收集、线程堆栈、JVM 运行时间等信息。

图形化诊断工具

- JVisualvm
- JProfiler







# 方法区

![img](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230131/i%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%80%BB%E8%A7%88.jpg)

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。

所以，方法区看作是一块独立于Java堆的内存空间。

<img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//jvm/20230209/%E6%96%B9%E6%B3%95%E5%8C%BA-2.png" alt="image-20230130165620395" style="zoom:50%;" />

**从线程共享与否的角度来看**

<img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230130/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20230130165424916" style="zoom:50%;" />

**堆、栈、方法区**

![image-20230130165910031](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230130/%E6%A0%88%E5%A0%86%E6%96%B9%E6%B3%95%E5%8E%BB.png)

**对方法区的基本理解：**

- 方法区（Method Area）与 Java堆 一样，是各个线程共享的内存区域

- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。

- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展

- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误： `java.lang.OutOfMemoryError: PermGen space` 或者 `java.lang.OutOfMemoryError: Metaspace`
-  关闭 JVM 就会释放这个区域的内存

**方法区的演进：**

方法区类似接口，永久代和元空间是方法区的不同实现

在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代

本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。、

现在来看，当年使用永久代，不是好的 idea。导致Java程序更容易 OOM（超过 `-XX:MaxPermsize` 上限）

而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存

永久代、元空间二者并不只是名字变了，内部结构也调整了

根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常



## 参数设置

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。

**jdk7 及以前：**

- 通过来设置永久代初始分配空间。默认值是 20.75 M `-XX:Permsize`

- 通过来设定永久代最大可分配空间。32 位机器默认是 64 M，64 位机器模式是 82M `-XX:MaxPermsize`

- 当 JVM 加载的类信息容量超过了这个值，会报异常 `OutOfMemoryError:PermGen space`。

**JDK8 以后：**

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize`指定

- 默认值依赖于平台。windows下，`-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1`，后者（最大值）一般不设置限制。

- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常`OutOfMemoryError:Metaspace`

- `-XX:MetaspaceSize`：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。

- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。

**如何解决 OOM：**

1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 
2.  如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 
3.  如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（`-Xmx`与`-Xms`），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 



## 方法区内部结构

《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：

> 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

**类型信息：**

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：

1. 这个类型的完整有效名称（全名=包名.类名）
2. 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）
3. 这个类型的修饰符（public，abstract，final的某个子集）
4. 这个类型直接接口的一个有序列表

**域（Field）信息：**

JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

**方法（Method）信息：**

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

1. 方法名称
2. 方法的返回类型（或void）
3. 方法参数的数量和类型（按顺序）
4. 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
6. 异常表（abstract和native方法除外） 

- - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

**non-final的类变量：**

- 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分

- 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它

**补充说明：全局常量（static final）：**

被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了



## 常量池

- 字节码文件，内部包含了常量池，方法区，内部包含了运行时常量池；就是说当字节码文件中的常量池加载到方法区后就成了运行时常量池

- 要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区；要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池

- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的**符号引用**

**为什么需要常量池？**

一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池

一个很小的 class 文件中可能需要包含非常多的引用，在字节码文件中用符号引用最大的好处就是不用把这些引用每次都写一遍，这样会浪费大量空间

总的来说，常量池就是一个配料表，JVM 需要做什么就先从配料表中寻找再组合到一起

**击中常量池内存储的数据类型包括：**

- 数量值

- 字符串值

- 类引用

- 字段引用

- 方法引用

**运行时常量池：**

- 运行时常量池（Runtime Constant Pool）是方法区的一部分。

- 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。

- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。

- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。

- 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。

- 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。

- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。



## 方法区的演进

1. 首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一
2. Hotspot中方法区的变化：

| **JDK1.6及之前** | **有永久代（permanet），静态变量存储在永久代上**             |
| ---------------- | ------------------------------------------------------------ |
| **JDK1.7**       | **有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中** |
| **JDK1.8**       | **无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中** |

**为什么移除永久代：**

由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间

这项改动是很有必要的，原因有：

为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 

```java
"Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space"
```

而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 对永久代进行调优是很困难的



## StringTable 为什么调整位置

jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发

这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存



##  静态变量存放位置

```java
/**
 * 静态引用对应的对象实体始终都存在堆空间
 * jdk7:
 * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails
 * jdk8:
 * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails
 */
public class StaticFieldTest {
    private static byte[] arr = new byte[1024 * 1024 * 100];
    public static void main(String[] args) {
        System.out.println(StaticFieldTest.arr);
        
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * staticobj、instanceobj、Localobj存放在哪里？
 */
public class StaticobjTest {
    static class Test {
        static ObjectHolder staticobj = new ObjectHolder();
        ObjectHolder instanceobj = new ObjectHolder();
        void foo(){
            ObjectHolder localobj = new ObjectHolder();
            System.out.println("done");
        }    
    }
    private static class ObjectHolder{
        public static void main(String[] args) {
            Test test = new StaticobjTest.Test();
            test.foo();
        }
    }
}
```

测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。

接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：

从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点



## 方法区的垃圾回收

有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏

**方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型**

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

- 类和接口的全限定名

- 字段的名称和描述符

- 方法的名称和描述符

HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收

回收废弃常量与回收Java堆中的对象非常类似

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

-  该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 

-  加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 

-  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class` 以及 `-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息

**在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力** 



## 常见面试题

百度：

说一下JVM内存模型吧，有哪些区？分别干什么的？

蚂蚁金服：

Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？

一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？

二面：Eden和survior的比例分配

小米：

jvm内存分区，为什么要有新生代和老年代

字节跳动：

二面：Java的内存分区

二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？

京东：

JVM的内存结构，Eden和Survivor比例。

JVM内存为什么要分成新生代，老年代，持久代。

新生代中为什么要分为Eden和survivor。

天猫：

一面：Jvm内存模型以及分区，需要详细到每个区放什么。

一面：JVM的内存模型，Java8做了什么改

拼多多：

JVM内存分哪几个区，每个区的作用是什么？

美团：

java内存分配 jvm的永久代中会发生垃圾回收吗？

一面：jvm内存分区，为什么要有新生代和老年代？





# 对象创建与直接内存

## 对象创建

![image-20230201143457614](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%AD%A5%E9%AA%A4.png)

### 1. 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）

如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；

- 如果没有找到文件，则抛出ClassNotFoundException异常

- 如果找到，则进行类加载，并生成对应的Class对象

### 2. 为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小

**如果内存规整**：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。

- 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞

**如果内存不规整**：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存

- 已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容

选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

### 3. 处理并发问题

- 采用CAS失败重试、区域加锁保证更新的原子性

- 每个线程预先分配一块TLAB：通过设置 `-XX:+UseTLAB`参数来设定

### 4. 初始化分配到的内存

所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用

### 5. 设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

### 6. 执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

**给对象属性赋值的操作**

- 属性的默认初始化

- 显式初始化

- 代码块中初始化

- 构造器中初始化



## 对象的内存布局

![image-20230201144300272](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

### 1.对象头（Header）

对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度

**运行时元数据**

- 哈希值（HashCode）

- GC分代年龄

- 锁状态标志

- 线程持有的锁

- 偏向线程ID

- 偏向时间戳

**类型指针**

指向类元数据InstanceKlass，确定该对象所属的类型。

### 2.实例数据（Instance Data）

它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）

- 相同宽度的字段总是被分配在一起

- 父类中定义的变量会出现在子类之前

- 如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙

### 3.对齐填充（Padding）

不是必须的，也没有特别的含义，仅仅起到占位符的作用



## 对象访问

一般有两种方式：

1. 句柄访问
2. 直接访问（Hotspot 采用的方式）

### 1. 句柄访问

![image-20230201145812633](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png)

### 2.直接访问

![image-20230201145915472](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png)





## 直接内存

不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存区间。来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。通常，访问直接内存的速度会优于Java堆，即读写性能高

- 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存

- Java的NIO库允许Java程序使用直接内存，用于数据缓冲区

**非直接缓冲区：**

使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。

**直接缓冲区：**

使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作

由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。

- 分配回收成本较高

- 不受JVM内存回收管理

直接内存大小可以通过`MaxDirectMemorySize`设置。如果不指定，默认与堆的最大值-Xmx参数值一致





# 执行引擎

执行引擎属于JVM的下层，里面包括解释器、及时编译器、垃圾回收器

执行引擎是Java虚拟机核心的组成部分之一

“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式

JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息

如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令.才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。



## 执行引擎的工作流程

1. 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
2. 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
3. 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息

从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程



## Java 代码编译与执行过程

![image-20230201151949273](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/Java%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png)

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

Java代码编译是由Java源码编译器（javac，前端编译器）来完成

Java字节码的执行是由JVM执行引擎（解释器和 JIT，后端编译器）来完成

**解释器与编译器：**

**解释器：**当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

**JIT（Just In Time Compiler）编译器：**就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言

注：为什么 Java 称为半编译半解释型语言？

JDK1.0 时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将「解释执行与编译执行二者结合」起来进行（所以半编译半解释不是先编译后执行）



## 解释器

JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法

### 解释器工作机制

解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行

当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作

### 解释器分类

在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器

- 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下

- 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能

在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成

- Interpreter模块：实现了解释器的核心功能

- Code模块：用于管理HotSpot VM在运行时生成的本地机器指令

### 现状

由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃

为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升

不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献



## JIT 编译器

### 代码执行类型

- 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 

-  第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 

HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间

在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步

**问题：**

有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行

首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高

所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率

同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”



### HotSpot 的执行方式

![image-20230201155008652](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8.png)

当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率

**案例：**

> 注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死
>
> 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队



### 概念解释

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程

也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程

还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程

-  前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）

-  JIT编译器：HotSpot VM的C1、C2编译器

-  AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET



### 热点代码及探测技术

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被**编译为本地代码的字节码**，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其**直接编译为对应平台的本地机器指令**，以此提升Java程序的执行性能

**一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”**，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为「栈上替换」（或简称为OSR（On Stack Replacement）编译）

一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能

目前HotSpot VM所采用的热点探测方式是「基于计数器的热点探测」

采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）

- 方法调用计数器用于统计方法的调用次数

- 回边计数器则用于统计循环体执行的循环次数

**方法调用计数器：**

![image-20230201155658126](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//JVM/20230201/%E6%96%B9%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A8.png)

这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译

这个阀值可以通过虚拟机参数 `-XX:CompileThreshold`来人为设定

当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求

**热点衰减：**

如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）

进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 `-XX:-UseCounterDecay` 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码

另外，可以使用`-XX:CounterHalfLifeTime`参数设置半衰周期的时间，单位是秒

**回边计数器：**

它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译



### 设置程序执行方式

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：

- `-Xint`：完全采用解释器模式执行程序

- `-Xcomp`：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行

- `-Xmixed`：采用解释器+即时编译器的混合模式共同执行程序



### JIT 分类

JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

- `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。

- `-server`：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高

分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化

不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务

**C1 和 C2编译器不同的优化策略：**

在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联、去虚拟化、冗余消除

- 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程

- 去虚拟化：对唯一的实现类进行内联

- 冗余消除：在运行期间把一些不会执行的代码折叠掉

C2的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在C2上有如下几种优化：

- 标量替换：用标量值代替聚合对象的属性值

- 栈上分配：对于未逃逸的对象分配对象在栈而不是堆

- 同步消除：清除同步操作，通常指synchronized



### 总结

一般来讲，JIT编译出来的机器码性能比解释器高。C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器

**Graal 编译器：**

- 自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器

- 编译效果短短几年时间就追评了C2编译器，未来可期

- 目前，带着实验状态标签，需要使用开关参数`-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler`去激活才能使用

**AOT 编译器：**

jdk9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）

Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中

所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程

最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验

缺点：

- 破坏了 java 一次编译，到处运行的理念，必须为每个不同的硬件，OS编译对应的发行包

- 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知

- 还需要继续优化中，最初只支持Linux X64 java base


