---
title: "设计模式"
shortTitle: "设计模式"
description: "设计模式"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-02-02
category: 
- "设计模式"
tag:
- "设计模式"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "设计模式"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "设计模式"
  description: "设计模式"
  author:
    name: gzw
    email: 1627121193@qq.com
---



# 设计模式



# 七大原则

注：下面的前五个也称为面向对象的五大基本原则



**1.单一职责原则（SRP）：**

> 类的功能要单一，不能包罗万象，跟杂货铺似的

- 一个类只负责一项职责

<br/>

**2.接口隔离原则（ISP）：**

> 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多

- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

<br/>

**3.依赖倒转原则（DIP）：**

> 就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的

- 高层模块不应该依赖底层模块，二者都应该依赖其抽象

- 抽象不应该依赖细节，细节应该依赖抽象

- 中心思想是面向接口编程

- 细节具有多变性，抽象具有稳定性

- 接口和抽象类的目的是制定规范，细节交给实现类实现

<br/>

**4.里氏替换原则（LSP，正确地使用继承）：**

> 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活

- 引用基类的地方必须能透明地使用其子类的对象

- 在使用继承时，在子类中尽量不要重写父类的方法

- 可以通过聚合/组合/依赖来解决重现方法的问题（加入 B 继承了 A 并且 B 需要重写方法，那么可以再提出一个基类，让 A/B 分别继承，即提到了同一个层级）

<br/>

**5.开闭原则（OCP）：**

> 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意

- 编程中最基础和最重要的设计原则

- 模块和函数应该对扩展开放（提供方），对修改关闭（使用方）。用抽象构框架，用实现扩展细节

- 需要增加新功能时，最好通过扩展来实现

- 设计模式的目的就是遵循开闭原则

<br/>

**6.迪米特法则（最少知道法则）：**

- 一个对象应该对其他对象保持最少的了解

- 尽量将逻辑封装在类的内部，对外只提供 public 方法，不对外泄露任何私密信息

- 称出现在成员变量，方法参数，方法返回值的类为直接朋友（两个类之间存在耦合关系即为朋友关系），出现在局部变量中的类不是直接朋友，即陌生的类最好不要以局部变量的形式出现在类的内部

<br/>

**7.合成复用原则：**

- 尽量使用合成/聚合的方式，而不是继承



<br/>

# 设计模式概述

## 1.核心思想

- 找出应用中可能需要变化的地方，把它们独立出来，不和那些不需要变化的代码混在一起

- 针对接口编程，不针对实现编程

- 为了交互对象直接的松耦合设计而努力

<br/>

## 2.目的

- 高内聚/低耦合

- 可维护性（可扩展性）

- 重用性：相同代码不必重复编写

- 可读性：编程规范，便于开发人员阅读和理解

- 可靠性：增加新的功能后对原本的功能没有影响

- 灵活性

- 让软件更好

<br/>

## 3.分类

**创建型（5）**：

> 对象实例化的模式，创建型模式用于解耦对象的实例化过程

1. 单例模式
2. 工厂模式
3. 抽象工厂模式
4. 原型模式
5. 建造者模式



<br/>

**结构型（7）**：

> 把类和对象结合在一起形成一个更大的结构

1. 适配器模式
2. 桥接模式
3. 装饰器模式
4. 组合模式
5. 外观模式
6. 享元模式
7. 代理模式



<br/>

**行为型（11）**：

> 类和对象如何交互，划分责任和算法

1. 模板模式
2. 命令模式
3. 访问者模式
4. 迭代器模式
5. 观察者模式
6. 中介者模式
7. 备忘录模式
8. 解释器模式
9. 状态模式
10. 策略模式
11. 责任链模式



<br/>

# 23 种设计模式

## 创建型（5）

### 1.单例模式

**8 种实现方法：**

- 饿汉式（3）

- 懒汉式（5）



<br/>

### 2.工厂模式

**1.简单工厂模式：**

- 简单工厂模式（静态工厂模式）是由一个工厂对象决定创建哪一类产品类的实例

- 定义了一个创建对象的类，有这个类俩封装实例化对象的行为

- 在开发种，当我们用到大量的创建某种/某类/谋批对象时，就会使用到工厂模式

**2.工厂方法模式：**

- 将实例化功能抽象成抽象方法
- 定义一个创建对象的抽象方法，有子类决定要实例化的类
- 工厂方法可以将对象的实例化推迟到「子类」



<br/>

### 3.抽象工厂模式

- 定义一个接口用于创建相关或有依赖关系的「对象簇」，无需指明具体的类
- 可以将「简单工厂模式」和「工厂方法模式」进行整合
- 从设计层面来看，抽象工厂模式就是对「简单工厂模式」和「工厂方法模式」的进一步抽象
- 将工厂抽象成两层，「抽象工厂」和「具体实现的工厂子类」，
- 可以根据创建对象类型使用相应的工厂子类，这样是将简单工厂类变成了工厂簇，利于代码的「维护」和「扩展」



<br/>

### 4.原型模式

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
>
> 这是一种创建型设计模式，允许一个对象在创建另外一个「可定制的对象」，无需知道创建的细节
>
> 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象，通过请求原型对象「拷贝，clone」他们自己来实施创建

**浅拷贝：**

- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象

- 对于数据类型是引用数据类型的成员变量，例如成员变量是，数据，某个类的对象等，那么浅拷贝会进行引用传递，也就是将改成员变量的引用值（内存地址）复制一份给新的对象，这样修改任意一个对象中成员变量的值都会改变最初引的成员变量的值

- 浅拷贝是使用默认的 clone() 方法来实现的

**深拷贝：**

- 复制对象的所有基本数据类型的成员变量值

- 可以动态地获得对象运行时的状态

- 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝

- 两种实现方式：
  - 重现 clone 方法来实现深拷贝
  - 通过对象序列化实现深拷贝



<br/>

### 5.建造者模式

- 又称为「生成器模式」，将产品和产品建造过程进行解耦

- 是一种对象构建模式，它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构建出不同表现的对象

- 逐步船舰复杂的对象，允许用户只通过指定复杂对象的「类型」和「内容」就可以构建他们，用户不需要知道内部的具体构建细节

- 四个角色：
  - Product（产品角色）：一个具体的产品对象
  - Builder（抽象建造者）：创建一个 Product 对象的各个部件指定的接口/抽象类
  - ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件
  - Director（指挥者）：构建一个使用 Builder 接口的对象，它主要是用于创建一个复杂的对象。主要有两个作用：
    - 隔离客户与对象的生产过程
    - 负责控制产品对象的生产过程



<br/>

## 创建型（7）

### 6.适配器模式

- 将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容

- 从用户的角度看不到「被适配者 」，是解耦的

- 用户调用适配器转化出来的目标i接口方法，适配器再调用「被适配者」的相关接口方法 

- 将一个类中的方法通过适配器进行一定的转换

- 分类：
  - 类适配器：使用继承的方式
  - 对象适配器：使用聚合的方式，体现了「合成复用原则」
  - 接口适配器：使用抽象类实现不同的接口的全部方法，只不过这些方法都是空方法，这样在真正使用的时候就可以单独重写一个方法（匿名类重写方法）并只使用该方法



<br/>

### 7.桥接模式

- 结构型设计模式

- 将「实现」和「抽象」放在两个不同的类层次中，使得两个层次可以「独立改变」

- 基于类的「最下设计原则」，通过使用「封装」、「聚合」和「继承」等行为让不同的类承担不同的职责

- 最主要的特点是把「抽象」与「行为实现」分离开来，从而可以保持各个部分的「独立性」以及应对他们的「功能扩展」



<br/>

### 8.装饰器模式

- 装饰器模式就像打包一个快递，主体是被修饰者，填充/纸板等的就为修饰物

- 动态地将新功能「附加」到对象上。在对象的扩展方面，他比继承更有「弹性」，装饰者模式也体现了开闭原则

- 装饰器中可以包含被装饰者，相当于把饮料往调料里边加，而不是把调料往饮料中加



<br/>

### 9.组合模式

- 结构型型模式

- 又称「部分整体模式」，它创建了对象组的树形结构，将对象组合成树状结构以表示「整体-部分」的关系

- 依据树形结构来组合对象，用来表示部分以及整体层次

- 使得用户对单个对象和组合对象的访问具有「一致性」，即组合能让客户以一致的方式处理个别对象以及组合对象



<br/>

### 10.外观模式

- 又称「过程模式」，位子系统中的「一组接口」提供一个「一致的界面」，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

- 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节



<br/>

### 11.享元模式

1. 又称「蝇量模式」，运用共享技术有效地支持大量「细粒度」的对象
2. 常用于系统的底层开发，解决系统性能问题。例如数据库连接池里边都是创建好的连接对象，在这些连接对象中我们需要的则直接拿来用，避免了重复创建，如果没有需要的则再创建一个
3. 能够解决重复对象的内存浪费问题，当系统中有大量相似的对象，需要缓冲池时，不需要总是创建新的对象，可以从缓存池中拿，这样可以降低系统内存，同时提高效率
4. 经典的应用场景就是「池」技术，String 常量池/数据库连接池/缓存池等都是享元模式的应用，这是「池」技术的重要实现方式



<br/>

### 12.代理模式

1. 为一个对象提供一个替身，以控制对这个对象的访问
2. 通过代理模式访问目标对象的好处是，可与在目标对象实现的基础上，增加「额外的功能操作」，即扩展目标对象的功能
3. 被代理的对象可以是「远程对象」，「创建开销打大」的对象，「需要安全控制」的对象
4. 代理模式有三种不同的形式：
   - 静态代理
     - 需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者是继承相同的父类
     - 能够在不修改目标对象功能的情况下，对目标功能进行扩展
   - 动态代理（JDK 代理/接口代理，主要是使用「反射」）
     - 代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用动态代理
     - 代理对象的生成是利用 JDK 的 API，动态地在内存中构建代理对象
   - Cglib 代理（可以在内存中动态地创建对象，而不需要实现接口，属于动态代理的范畴）
     - 又称子类代理，当目标对象只有一个单独的对象的时候，没有任何的接口，这个时候就可以用目标对象子类来实现代理
     - 它是在内存中构建一个子类对象从而实现对目标对象功能扩展
     - Cglib 是一个强大的高性能的代码生成包，它可以在运行期间扩展 Java 类与实现 Java 接口，它广泛地被许多 AOP 框架使用，实现方法拦截
     - 在 AOP 编程中的两种代理：
       - 目标对象需要实现接口，用 JDK 代理
       - 目标对象不需要实现接口，用 Cglib 代理
     - Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类

5. 代理模式的变体：
   - 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问
   - 缓存代理：例如：当请求图片文件等资源时，先到缓存代理取，如果取不到资源再到公网或者数据库取，之后再缓存
   - 远程代理：远程对象的本地代表，通过它可以把远程对象当成本地对象来调用。远程代理通过网络和真正的远程对象沟通信息
   - 同步代理：主要使用在多线程编程中，完成多线程间的同步工作



<br/>

## 行为型（11）

### 13.模板方法模式

![image-20220728144153206](http://lsky.gzw-icu.com/i/2022/10/12/12-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 行为型模式

- 模板模式在一个抽象类公开定义了执行它的方法的模板
- 它的子类可以按需重写方法实现，但调用将以抽象类中定义的方法进行
- 简单说就是定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构就可以重新定义某些特定的步骤

- 基本思想：
  - 算法或说逻辑只存在于父类中
  - 需要修改时，子类只需要也只能修改其中的某些步骤
  - 实现最大化代码复用
  - 统一算法的同时提供较大的灵活性，即父类模板方法保证结构不变，子类灵活实现
- 不足之处：
  - 每一个不同的实现都需要一个子类实现，导致类的数量增加而变得复杂
- 模板方法一般都是用 final 关键字防止子类覆盖
- 模板模式的使用场景：
  - 当在完成某个过程时需要执行一系列步骤
  - 这一系列步骤基本相同，但是个别步骤在实现时可能不同

**使用实例：**

- 统计代码运行时间

**钩子方法：**

- 在模板模式的父类中，可以定义一个默认不做任何事的方法，子类可以视情况来决定需不需要覆盖它，这种方法称为【钩子方法】

**简单例子：**制作豆浆，分为四步：

- 选材
- 加入配料（交给子类实现）
- 浸泡
- 打磨

```java
/**
 * 调用者
 */
public class Client {
    public static void main(String[] args) {
        System.out.println("======== 制作红豆豆浆 ========");
        SoyaMilk readBeanSoyaMilk = new ReadBeanSoyaMilk();
        readBeanSoyaMilk.make();

        System.out.println("======== 制作花生豆浆 ========");
        SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
        peanutSoyaMilk.make();

        System.out.println("======== 制作纯豆浆 ========");
        SoyaMilk pureSoyaMilk = new PureSoyaMilk();
        pureSoyaMilk.make();
    }
}
```

```java
/**
 * @desc 豆浆制作，抽象方法，其中包含一个狗子方法，决定是否需要加入配料
 * @author gzw
 */
public abstract class SoyaMilk {
    /**
     * 制作豆浆的方法
     * 使用 final 不让子类覆盖
     */
    final void make() {
        select();
        if (isWantCondiments()) {
            addCondiments();
        }
        soak();
        beat();
    }

    /**
     * 选材料
     */
    void select() {
        System.out.println("no.1 选择好的新鲜黄豆");
    }

    /**
     * 添加不同的配料
     * 抽象方法给子类具体实现
     */
    abstract void addCondiments();

    /**
     * 浸泡黄豆
     */
    void soak() {
        System.out.println("no.3 黄豆和配料浸泡");
    }

    /**
     * 打磨
     */
    void beat() {
        System.out.println("no.4 黄豆和配料打磨");
    }

    /**
     * 钩子方法
     * 决定是否需要添加配料
     */
    boolean isWantCondiments() {
        return true;
    }
}
```

```java
/**
 * 纯豆浆，不加入任何配料，所以抽象方法空实现，钩子方法返回空
 */
public class PureSoyaMilk extends SoyaMilk {
    @Override
    void addCondiments() {}

    @Override
    boolean isWantCondiments() {
        return false;
    }
}
```

```java
/**
 * 花生豆浆
 */
public class PeanutSoyaMilk extends SoyaMilk {
    @Override
    void addCondiments() {
        System.out.println("no.2 加入花生");
    }
}
```

**框架使用：**

- IOC 容器初始化时运用了模板模式

![image-20220728154712793](http://lsky.gzw-icu.com/i/2022/10/12/12-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-IOC/2022/10/12.png)



<br/>

### 14.命令模式

![image-20220728162538512](http://lsky.gzw-icu.com/i/2022/10/12/13-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 命令模式使得请求的【发送者】与【接收者】彼此之间解耦合，让对象直接的调用关系更加灵活
- 在命令模式中会将一个请求封装成一个对象，以便使用不同的参数来表示不同的请求，同时也支持可撤销的操作
- 类似打仗时将军发号施令，士兵执行命令，其中有几个关键的角色：
  - 将军：命令发布者
  - 士兵：命令的具体执行者
  - 命令：连接将军和士兵
- 可以设计一个命令队列，只要将命令放到队列中就可以通过多线程执行命令
- 不足之处：
  - 可能导致某些系统有过多的具体命令类，增加系统的复杂度
- 其中会使用到空命令，这也可以看作一种设计模式，因为让我们省去了判空的操作，如果没有则需要在执行每一个命令前判断是否为空

**使用场景：**

- 我们需要向某些对象发送请求，但是不知道具体的接收者是谁，也不知道被请求的操作是哪一个
- 此时需要在程序运行时指定具体的接收者，即可以使用命令模式设计

**使用实例：**

- 界面的每一个按钮都是一条命令，与 cmd 中的命令类似

**简单例子：**智能家居控制

![image-20220728163542548](http://lsky.gzw-icu.com/i/2022/10/12/13-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/2022/10/12.png)

**框架使用：**spring 框架中的 JdbcTemplate

 

<br/>

### 15.访问者模式

![image-20220728183046126](http://lsky.gzw-icu.com/i/2022/10/12/14-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 访问者模式用于封装一些作用于某种数据结构的各种元素的操作
- 可以在不改变数据结构的前提下定义作用域这些元素的新的操作
- 主要将数据结构于数据操作分离，解决数据结构和操作耦合性的问题
- 基本工作原理为：在被访问的类中加一个对外提供接待访问者的接口
- 角色以及职责：
  - Visitor：抽象的访问者，为该对象结构中的 ConcreteElement 的每一个类声明一个 visit 操作
  - ConcreteVisitor：是一个具体的访问者，实现每个 Visitor 声明操作
  - ObjectStructure：能够枚举它的元素，可以提供一个高层的接口，用于允许访问者访问元素 
  - Element：定义了一个 accept 方法，接收一个访问者对象
  - ConcreteElement：为具体元素，实现了 accept 方法
- 其中会使用到双分派，指不管类怎么变化，都能找到期望的方式运行，意味着得到执行的操作取决于请求的种类和两个接收者的类型
- 优点：
  - 符合单一职责原则，让程序具有优秀的扩展性，灵活性非常高
  - 可以对功能进行统一，适用于数据结构相对稳定的系统

- 缺点：
  - 具体元素要对访问者公布细节，即访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变成比较困难
  - 违背了依赖倒置原则，即访问者依赖的是具体元素，而不是抽象元素

**使用场景：**

- 有比较稳定的数据结构并且又有经常变化的功能需求
- 需要对一个对象结构中的对象进行很多的不同的操作，这些操作彼此之间没有关联
- 避免这些操作【污染】这些对象的类

**使用实例：**

- 报表
- UI
- 拦截器与过滤器

**简单例子：**观众投票 

![image-20220728201851385](http://lsky.gzw-icu.com/i/2022/10/12/14-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-%E6%8A%95%E7%A5%A8/2022/10/12.png)



<br/>

### 16.迭代器模式

![image-20220728213628723](http://lsky.gzw-icu.com/i/2022/10/12/15-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 行为型模式
- 如果集合元素使用不同的方式实现的，当客户端需要遍历这些集合元素时就要使用多种遍历方式，而且会暴露元素的内部结构
- 迭代器模式提供一种遍历集合元素的统一接口，用一致的方法遍历元素，不需要知道集合对象的底层表示，即不暴露元素的内部结构
- 角色与职责：
  - Iterator：迭代器接口
  - ConcreteIterator：具体的迭代器类，管理迭代
  - Aggregate：一个统一的聚合接口，将客户端与具体聚合解耦
  - ConcreteAggreage：具体的聚合持有对象的集合
- 优点：
  - 提供了一个统一的方法遍历对象，客户不需要再考虑聚合的类型，使用一个方法就可以遍历对象
  - 隐藏了聚合的内部结构
  - 提供了一种设计思想，即一个类应该只有一个引起变化的原因（单一职责），在聚合类中，把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来，依赖集合改变也只会影响到聚合对象，遍历方式改变也只会影响到迭代器
- 缺点：
  - 每个聚合对象都要一个迭代器，会产生多个迭代器导致复杂度上升

**使用场景：**

- 当要展示一组相似的对象，或者遍历一组相同对象

 

<br/>

### 17.观察者模式

![image-20220730153859190](http://lsky.gzw-icu.com/i/2022/10/12/16-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**需求：**

气象站天气推送设计

- 气象站可以将每天测量到的温度、气压、湿度等以公告的形式发布出去
- 需要设计开放型 API，便于第三方介入获取数据

- 角色：
  - 气象站：Subject，负责登记注册、移除、通知
  - 第三方介入网站：Observer，接收输入

**概述：**

- 对象之间多对一依赖的一种设计方案
- 被依赖的对象为 Subject，依赖的对象为 Observer
- Subject 通知 Observer 变化的信息 

**框架使用：**

- JDK 中有使用观察者模式
- 其中的 Observable 就是 Subject，只不过 Observable 是类而不是接口
- 因为 Observable  是类，所以 Observer 要通过继承来实现观察者模式



<br/>

### 18.中介者模式

![image-20220731142826546](http://lsky.gzw-icu.com/i/2022/10/12/17-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 行为型模式

- 用一个中介对象来封装一系列的对象交互
- 中介者使各个对象不需要显示地互相引用，从而解耦合
- 就如 MVC 模式，Controller 就是中介 
- 减少了类间的依赖，降低了耦合，符合迪米特原则
- 但是中介者承担了较多的责任，一旦中介者出现问题，那么整个系统都会受影响
- 如果设计不当，中介者对象本身会变得过于复杂，这点在实际应用时应当注意

**案例：**

![image-20220731143554565](http://lsky.gzw-icu.com/i/2022/10/12/17-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%AE%B6%E5%B1%85/2022/10/12.png)



<br/>

### 19.备忘录模式

![image-20220731151534383](http://lsky.gzw-icu.com/i/2022/10/12/18.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 行为型模式
- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象外保存这个状态
- 之后可以将对象恢复成原先保存的状态
- 实现了信息的封装，使得用户不需要关心状态的保存细节
- 但是如果类的成员变量过多，会占用比较大的资源，而且每次保存都会消耗一定的内存

- 为了节约内存，可以配合原型模式使用

**使用场景：**

- 游戏存档
- 操作撤销

- 数据库的事务管理



<br/>

### 20.解释器模式

![image-20220731155759281](http://lsky.gzw-icu.com/i/2022/10/12/19-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 在编译原理中，一个算数表达式通过词法分析器形成词法单元，而这些词法单元再通过语法分析器构建语法分析树，最终形成一个抽象的语法分析树
- 词法分析器和语法分析器都可以看作解释器
- 解释器模式是指给定一种语言（表达式），定义它的文法的一种表示，并定义一个解释器。使用该解释器来解释语言中的句子（表达式）
- 角色说明：
  - Context：环境角色，含有解释器之外的全局信息
  - AbstactExpression：抽象表达式，声明一个抽象的解释操作，这个方法为抽象语法树中所有的节点所共享
  - TerminaExpression：为终结符表达式，实现与文法中的终结符相关的解释操作
  - NonTermialExpression：为非终结符表达式，为文法中的非终结符实现解释操作
- 当一个语言需要解释执行，可以将语言中的句子表示成一个抽象语法树，使用解释器模式，让程序具有良好的扩展性
- 但是使用解释器可能会引起类膨胀；如果解释器模式采用递归调用方法，将导致调试变得复杂，效率也可能低下

**使用场景：**

- 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
- 一些重复出现的问题可以用一种简单的语言来表达
- 一个简单语法需要解释的场景
- 编译器
- 运算表达式计算
- 正则表达式

**案例：**

![image-20220801133213379](http://lsky.gzw-icu.com/i/2022/10/12/19-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-%E8%BF%90%E7%AE%97%E5%99%A8/2022/10/12.png)

**框架使用：**

- spring 中的 Expression 运算器就是使用的解释器模式设计的



<br/>

### 21.状态模式

![image-20220802151112792](http://lsky.gzw-icu.com/i/2022/10/12/20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 主要是用来解决对象在多种状态转换时，需要对外输出不同的行为的问题
- 状态和行为是一一对应的，状态之间可以互相转换
- 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

- 角色说明：
  - Context：环境角色，用于伟华 State 实例，这个实例定义当前状态
  - State 时抽象状态角色，定义一个接口封装与 Context 的一个特定接口的相关行为
  - ConcreteState 具体的状态角色，每个子类实现一个与 Context 的一个状态相关的行为
- 优点：
  - 让代码具有很强的可读性
  - 状态模式将每个状态的行为封装到一个类中，方便维护
  - 可以将容易产生问题的 if-else 语句删除
  - 符合开闭原则，容易增删状态
- 缺点：
  - 容易产生很多类，每个状态都要有一个对应的类，当状态过多时会产生大量的类，难以维护

**使用场景：**

- 当业务流程设计很多状态时，可以使用状态模式去除大量的 if-else 判断

- 当一个事件或者对象有很多种状态且状态之间会互相转化，对不同的状态也要求有不同的行为时，可以考虑使用状态模式

**使用实例：**

- 借贷平台订单的审核-发布-抢单流程

**案例：**（抽奖问题）

![image-20220802151924801](http://lsky.gzw-icu.com/i/2022/10/12/20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E5%A5%96/2022/10/12.png)



<br/>

### 22.策略模式 

![image-20220802163654937](http://lsky.gzw-icu.com/i/2022/10/12/21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 策略模式可以定义算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于使用算法的客户
- 让变化的代码从不变的代码中分离开来
- 针对接口编程而不是具体类（定义了策略接口）
- 多用组合/聚合而不是继承（客户端通过组合方式使用策略）；用行为类组合而不是行为类的继承
- 策略模式的关键是分析项目中变化和不变的部分
- 对修改关闭，对扩展开放，避免使用大量的 if-else
- 提供了可以替换继承关系的办法：策略模式将算法封装在独立的 Strategy 类中，使得可以独立于其他 Context 改变算法，即做到了易于切换、理解、扩展
- 但是每添加一个策略就要增加一个类，当策略过多就会难以管理

**案例：**（鸭子分类问题）

![image-20220802164339679](http://lsky.gzw-icu.com/i/2022/10/12/21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E9%B8%AD%E5%AD%90%E5%88%86%E7%B1%BB/2022/10/12.png)

**框架使用：**

- JDK 中 Arrays 的 Comparator 使用了策略模式



<br/>

### 23.责任链模式

![image-20220802173045376](http://lsky.gzw-icu.com/i/2022/10/12/22-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/2022/10/12.png)

**概述：**

- 又叫职责链模式，为请求创建一个接收者对象的链条，这样可以对请求的发送者和接收者进行解耦
- 责任链模式中通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么他会把相同的请求传给下一个接收者，以此类推
- 角色说明：
  - Handler：抽象的接收者，定义了一个处理请求的接口，同时包含了其他的 Handler
  - ConcreteHandlerA，B：具体的处理者，处理它自己负责的请求，可以访问它的后继者（即下一个处理者）；如果当前请求自己可以处理就接收，如果不可以者交给后继者处理
  - Request：含有很多属性，表示一个请求 

**案例：**（OA 系统采购审批需求，不同金额由不同人负责） 

![image-20220802181001184](http://lsky.gzw-icu.com/i/2022/10/12/22-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-%E5%AE%A1%E6%89%B9/2022/10/12.png)



<br/><br/>