---
title: "MySQL 基础知识"
shortTitle: "MySQL 基础知识"
description: "MySQL 基础知识"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2021-05-29
category: 
- "mysql"
- "数据库"
tag:
- "mysql"
- "数据库"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "MySQL 基础知识"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "MySQL 基础知识"
  description: "MySQL 基础知识"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# MySQL 基础知识

注：中文括号（）代表补充说明，英文括号()是语句的内容，不是补充不可省略。



## 前言

### 数据库的优点
1. 可以持久化数据到本地  
2. 结构化查询



### 数据库的常见概念

1. DB：数据库，存储数据的仓库  
2. DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建与管理数据库  
3. SQL：结构化查询语言，用于和数据库通讯的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件的通用语言  



### 数据库存储数据的特点 

1. 数据存放到表中，然后表再放到库中  
2. 一个库中可以有多张表，每张表具有唯一的表名来表示自身  
3. 表中有一个或多个列，列又被称为“字段”，相当于Java中的“属性”  
4. 表中的每一行数据，相当于Java中的“对象”  



### 常见的数据库管理系统  

1.MySQL
2.Oracle  
3.DB2  
4.SQLserver  



### MySQL的背景  

- 前身属于瑞典的一家公司，MySQL AB，后被Sun公司收购，最后Sun公司被Oracle收购  



### MySQL的优点  

- 开源、免费、成本低  
- 性能高、移植性好  
- 体积小，便于安装  



### MySQL的安装  

>属于c/s架构的软件，既有服务端又有客户端，一般安装服务端  

**相关命令：**

| 序号 |                             命令                             |      解释      |
| :--: | :----------------------------------------------------------: | :------------: |
|  1   |                       net start mysql                        |   启动 mysql   |
|  2   |                        net stop mysql                        |   关闭 mysql   |
|  3   | mysql -uroot -p / mysql -h localhost -P 3306 -u root -p (+password) |   登入 MySQL   |
|  4   |                  mysql --version / mysql -V                  | 查看数据库版本 |
|  5   |                        exit / ctrl+c                         |   退出 MySQL   |



### 事务四大特性与隔离级别

- 原子性
- 一致性
- 隔离性
- 持久性

| 隔离级别（Isolation Level） | 脏读（Dirty Reads） | 不可重复读（Nonrepeatable Reads） | 幻读（Phantoms） |
| :-------------------------: | :-----------------: | :-------------------------------: | :--------------: |
|          读未提交           |        允许         |               允许                |       允许       |
|          读已提交           |       不允许        |               允许                |       允许       |
|          可重复读           |       不允许        |              不允许               |       允许       |
|           串行化            |       不允许        |              不允许               |      不允许      |



### 数据库的备份（命令行方式）

**备份：**

- 进入 `mysql` 的 `bin` 目录，输入如下命令
- 将其中的 `username` 替换成 `root` 或其他用户，`password` 替换成数据库的真实密码，`databasename` 替换成需要备份的数据库名

```sql
mysqldump -u username -ppassword databasename > databasename.sql
```

**恢复：**

- 进入 `mysql` 的 `bin` 目录，再登入mysql，输入如下命令

- 将其中的 `databasename` 更换成对应的备份文件的名称

```sql
source databasename.sql;
```





### MySQL中的注意点

1. MySQL中没有字符串的概念，只有字符，用‘’单引号表示（不区分单双引号，一般用单引号）  
2. MySQL中+只是运算符，若字符相加则先将字符转化成数值再相加，若是转化失败，则将字符直接转换成数值0再相加；若用+的表达式中有一个值为null，结果一定为null
3. MySQL中为了区别特殊字段和关键字时，有时会将特殊字段用双引号区别开来
4. 着重符号为：``  
5. 转义符为：\ 或者自己指定转义符（见下面的模糊查询）





## MySQL的语法规范

1. 不区分大小写，但是建议关键字大写，表名列名小写 
2. 每条命令用 “;” 结尾  
3. 根据每条命令的需要，可以进行换行或者缩进  
4. 注释：
   1. 单行注释：`#注释文字`   
   2. 单行注释：`--注释文字`  
   3. 多行注释：`/* 注释文字 */`



### 数据类型

| 数据类型  | 描述                                                  |
| --------- | ----------------------------------------------------- |
| INT       | 整型，用于存储整数值                                  |
| FLOAT     | 浮点型，用于存储浮点数值                              |
| DOUBLE    | 双精度浮点型，用于存储高精度浮点数值                  |
| DECIMAL   | 十进制数型，用于存储高精度数字                        |
| CHAR      | 固定长度字符串类型，最多可存储255个字符               |
| VARCHAR   | 可变长度字符串类型，最多可存储65535个字符             |
| TEXT      | 长文本类型，用于存储大文本数据，最多可存储65535个字符 |
| DATE      | 日期类型，用于存储日期值                              |
| TIME      | 时间类型，用于存储时间值                              |
| DATETIME  | 日期时间类型，用于存储日期和时间值                    |
| TIMESTAMP | 时间戳类型，用于存储时间戳值                          |
| BOOLEAN   | 布尔类型，用于存储true/false值                        |





### 显示数据库 
```mysql
show databases;
```


### 进入指定数据库

```mysql
use 指定数据库名;
```


### 显示表

```mysql
show tables;
```


### 直接查看指定数据库

```mysql
show tables from 指定数据库名;
```


### 查看当前处于哪个库(调用函数)

```mysql
select database();
```


### 创建表（需要指定有哪些列）

```mysql
create table 表名(
    列名 类型,
    id int,
    name varchar(20)
);
```


### 查看表的结构

```mysql
desc 表名
```


### 查看表中的数据

```mysql
select * from 表名
```


### 想表中插入数据

```mysql
insert into 表名 (列名,列名) values(数据,数据);
```


### 修改表中的数据

```mysql
update 表名 set 列名=值 where 限定条件（如id=1）
```









## 索引



### 索引类型

| 索引类型                      | 说明                                                         | 使用场景                                                     |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 主键索引（Primary Key Index） | 唯一标识一条记录，一个表只能有一个主键索引，一般会自动创建，可用于加速数据的查找和更新操作 | 经常根据主键查询的场景                                       |
| 联合索引（Composite Index）   | 可以覆盖多个数据列，如 INDEX(columnA, columnB) 索引          | 频繁使用的条件放在联合索引的前面可以更好地利用索引，提高查询效率 |
| 唯一索引（Unique Index）      | 值必须唯一，但允许空值，可以用于加速数据的查找和更新操作，避免重复数据的插入 | 需要保证某些列或者组合列的唯一性                             |
| 普通索引（Index）             | 最基本的索引类型，可用于加速数据的查找和排序操作，但不会强制唯一性，允许被索引的数据列包含重复的值 | 经常作为WHERE子句中的列                                      |
| 全文索引（Full-text Index）   | 用于全文搜索的一种特殊索引类型，可以加速全文搜索的查询       | 对文本类型的列进行模糊搜索的场景                             |
| 空间索引（Spatial Index）     | 用于地理空间数据类型的一种特殊索引类型，可以加速空间数据的查询 | 存储位置信息的场景                                           |

需要注意的是，不同类型的索引在使用场景和性能方面有所区别，选择正确的索引类型可以提高数据库的性能。同时，在创建索引时需要考虑索引的数量和列的选择，过多的索引和不合理的列选择可能会影响数据库的性能，因此需要根据具体的场景进行选择和设计。







### 原理

通俗来说，索引就是把 **无序** 的数据变成 **有序** 的查询， 过程大致为：

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成 **倒排表**
3. 在倒排表内容上拼接数据地址链
4. 在查询的时候，先拿到倒排表的内容，再取出数据地址链，从而拿到具体数据

<br/>

索引是数据库优化的重要手段之一，它是一种数据结构，用于加快数据库查询的速度。索引的原理主要涉及以下几个方面：

1. B-Tree 索引：B-Tree 索引是最常见的索引类型。B-Tree 索引是一种平衡树结构，可以有效地支持范围查询、排序查询等操作。B-Tree 索引将所有数据按照索引列的值排序，并在每个节点上存储索引值和指向下一个节点的指针，这样就可以通过二分查找快速定位需要的数据。
2. Hash 索引：Hash 索引是一种哈希表结构，适用于等值查询。Hash 索引将索引列的值计算哈希值，将哈希值作为索引，在哈希表中查找对应的数据。Hash 索引的查询效率非常高，但不支持范围查询、排序查询等操作。
3. 聚簇索引：聚簇索引是一种特殊的索引类型，它的索引键和数据行是存储在一起的。聚簇索引可以使数据的访问更加快速，因为相同索引键的数据行通常都存储在相邻的位置上。
4. 非聚簇索引：非聚簇索引是一种将索引键和数据行分开存储的索引类型。非聚簇索引将索引键和指向数据行的指针分别存储在索引结构和数据表中，这样可以提高查询效率。

索引的原理可以简单概括为将数据按照索引列的值进行排序或哈希，从而快速定位需要的数据。但是，索引也会带来一些负面影响，例如增加数据插入和更新的成本、占用存储空间等。因此，在使用索引时，需要根据具体情况进行合理的设计和使用。











### B 树和 B+ 树

B树和B+树都是常用的数据结构，用于实现数据库索引。它们之间的区别如下：

1. 存储方式：B树中每个节点既存储数据，也存储索引信息；而B+树中只有叶子节点存储数据，非叶子节点只存储索引信息。
2. 叶子节点指针：B树中每个节点都有指向子节点的指针；而B+树中只有叶子节点有指向下一个叶子节点的指针，非叶子节点没有指向下一层的指针。
3. 数据查找：B树可以在所有节点中进行数据查找，而B+树只能在叶子节点中进行数据查找。
4. 节点大小：B树中每个节点存储的数据量比B+树要多，因为B树中每个节点都存储数据；而B+树中每个节点只存储索引信息，因此可以存储更多的索引信息。
5. 磁盘I/O操作：B+树的叶子节点形成一个有序链表，因此可以使用顺序I/O进行读取，效率更高。而B树中，每个节点都存储数据，因此在进行数据查找时需要进行随机I/O操作，效率较低。

综上所述，B+树相对于B树来说，更适用于存储海量数据和范围查询，可以提高数据查询的效率和磁盘I/O操作的效率。而B树则更适用于存储数据量较小的索引，可以提高单次查询的效率。

<br/>

B+树之所以在叶子节点中进行数据查找效率更高，是因为在B+树的叶子节点上采用了链表的形式来存储数据，而且这个链表是有序的，可以进行范围查询。另外，由于所有叶子节点都被链接在一起，可以采用顺序I/O的方式来读取数据，因此可以减少随机I/O的次数，提高了查询效率。

当我们需要查询一条数据时，在B树中，需要从根节点一层一层地向下遍历，直到找到该数据所在的叶子节点，然后再在该节点中进行数据查找。由于B树中每个节点都存储数据，因此需要进行多次随机I/O操作，这会严重影响查询效率。

而在B+树中，只需要进行一次二分查找就可以找到对应的叶子节点，然后通过链表遍历就可以查找到该数据。由于叶子节点是有序的，可以进行范围查询，这在处理一些数据量较大的范围查询时效率更高。同时，由于数据只存在于叶子节点中，而非叶子节点只存储索引信息，因此B+树的高度相对较小，可以进一步减少随机I/O的次数，提高查询效率。

综上所述，B+树在叶子节点中寻找数据的方式可以提高查询效率，并且链表结构的形式也为范围查询提供了便利。

<br/>

MySQL 索引使用的是 B+ 树，因为索引是用来加速查询的，而 B+ 树通过对数据进行排序所以是可以提高查询速度的。由于一个节点中可以存储多个元素，所以 B+ 树的高度一般都不会太高。在 MySQL 中一个 InnoDB 页就是一个 B+ 树节点，该页默认为 16kb，所以一般情况下一颗 **两层** 的 B+ 树可以存储 2000 万行左右的数据，然后通过利用叶子节点存储的所有数据进行排序，可以很好地支持全表扫描、范围查询等语句





### 索引设计原则

1. 适合索引的列是出现在 **where** 子句中的列，或者 **连接子句** 中指定的列
2. 基数较小的类的索引效果较差，没有必要在此列建立索引
3. 使用短索引：如果对长字符串进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余索引是否可以匹配
4. 定义有 **外键** 的列一定建立索引
5. 更新频繁的字段不适合建立索引
6. 不能有效区分数据的列不适合做索引（如性别）
7. 加索引时尽量扩展索引而不是直接添加，例如已经有了 a 索引，那么只需要修改原来的索引从而达成 (a, b)
8. 对于查询中很少涉及到的列，且重复值较多的列不适合建立索引
9. 对于定义为 text、image、bit 的数据类型的列不适合建立索引



### 索引使用注意点

1. 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么将无法使用索引。索引页面搜索中严禁 **左模糊** 和 **全模糊**，是在需要那么应该用专门的搜索引擎
2. 对于索引选择性太差的查询语句，查询优化器可能会直接选择全表扫描。比如查询手机号码时，建立了对应字段的索引，但是使用了 `1%` 作为模糊查询的条件，那么大概率会直接走全表扫描
3. 索引和执行时间没有必然的关系，确定查询执行效率的是：**扫描行数** 和 **回表次数**



### 索引优化

1. 增加多种不同规格索引以提高索引选择性（5~6组）
2. 空间换时间：使用定时任务增加时报、日报等中间结果
3. 边缘运算数据压缩（分布式计算后压缩成少量信息再上报）
4. 硬件调优：增大 `innodb_buffer_pool` ，即增大内存减少硬盘回表



### 索引覆盖

就是一个 SQL 执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回



### 执行计划

Explain 各个字段的含义

| 字段名称      | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 每个表或者查询的子查询都有一个唯一的标识符。在执行查询时，MySQL会根据这些标识符按照某种顺序依次执行查询操作。 |
| select_type   | 查询类型，常见的类型包括SIMPLE（简单查询）、PRIMARY（主查询）、UNION（联合查询）等。 |
| table         | 查询涉及到的表的名称。                                       |
| partitions    | 如果查询使用了分区表，该字段会显示查询使用的分区。           |
| type          | MySQL在执行查询时使用的访问方式，常见的访问方式包括ALL（全表扫描）、index（索引扫描）、range（范围扫描）、ref（使用非唯一索引或唯一索引的前缀进行匹配）等。 |
| possible_keys | MySQL可以使用的索引列表，多个索引以逗号分隔。                |
| key           | MySQL实际使用的索引，如果为NULL，则表示没有使用索引。        |
| key_len       | MySQL在使用索引时使用的索引长度。                            |
| ref           | MySQL在使用索引时使用的列或者常量。                          |
| rows          | MySQL在执行查询时估计需要扫描的行数。                        |
| filtered      | 查询结果的行数在返回结果集之前被过滤掉的百分比。             |
| Extra         | 包含了一些额外的信息，例如是否使用了临时表、是否使用了文件排序等。 |

==id==：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id的顺序是按 select 出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。



==selectType==: 表示查询中每个select子句的类型：

1. SIMPLE： 表示此查询不包含 UNION 查询或子查询
2. PRIMARY： 表示此查询是最外层的查询（包含子查询）
3. SUBQUERY： 子查询中的第一个 SELECT
4. UNION： 表示此查询是 UNION 的第二或随后的查询
5. DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询
6. UNION RESULT, UNION 的结果
7. DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
8. DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）



==type==：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：

1. const：通过索引一次命中，匹配一行数据
2. system: 表中只有一行记录，相当于系统表；
3. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
4. ref: 非唯一性索引扫描,返回匹配某个值的所有
5. range: 只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>；
6. index: 只遍历索引树；
7. ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。



==rows==：mysql 查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大



==filtered==：返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少



==extra==：

1. using filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
2. using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
3. using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
4. using where ：sql使用了where过滤,效率较高





### 最左前缀原则

最左前缀原则是指对于一个联合索引（复合索引）来说，如果在查询语句中只使用了该联合索引的前缀部分，那么MySQL就可以利用这个联合索引进行数据的匹配和查询。

具体来说，如果一个联合索引包含多个列，那么在查询时必须满足以下条件：

1. 查询语句中的条件从联合索引的最左侧开始；
2. 查询时只能使用联合索引的连续一段，不能跳过中间的列；
3. 如果在联合索引的某个列上使用了范围查询（例如 BETWEEN、>、< 等），那么该列右侧的所有列都无法使用索引。

最左前缀原则的作用在于优化查询语句的性能。如果一个表有多个列需要使用索引，可以考虑建立一个联合索引来提高查询效率。但是需要注意的是，在建立联合索引时，要根据最常用的查询顺序来决定索引的顺序，以保证最左前缀原则的使用。





## 事务

### 事务的基本特性 ACID

| 中文名 | 英文名      | 解释                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| 原子性 | Atomicity   | 事务是一个原子操作单元，不可再分割，要么全部执行成功，要么全部不执行 |
| 一致性 | Consistency | 事务执行前后，数据库的完整性约束没有被破坏                   |
| 隔离性 | Isolation   | 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行 |
| 持久性 | Durability  | 事务完成后，对数据库的修改是永久的，即使系统故障也不会丢失   |

==特别说明：==

在数据库中，完整性约束是指数据库中数据的正确性、有效性、一致性等方面的限制条件，用来保证数据的正确性。例如，主键约束保证每行数据都具有唯一标识符，外键约束保证表与表之间的数据关系正确等。

事务的一致性特性指的是，在事务执行前后，数据库中的完整性约束没有被破坏。也就是说，在一个事务执行前，数据库中的完整性约束已经被满足，事务执行后，数据库中的完整性约束仍然得到保持。

例如，如果一个事务包含了多个操作，其中包括插入、更新、删除等操作，如果这些操作执行后，数据库中的主键、唯一约束、外键等完整性约束仍然被满足，那么就可以认为这个事务是满足一致性特性的。

如果在一个事务中，某个操作破坏了数据库中的完整性约束，那么这个事务就不能满足一致性特性，事务必须被回滚，所有的操作都要撤销，直到数据库中的完整性约束再次被满足。因此，保证数据的完整性约束是非常重要的，事务的一致性特性也是保证数据完整性约束的重要保障之一。



### InnoDB 事务实现

InnoDB 是通过 `Buffer Pool`、`LogBuffer`、`RedoLog`、`UndoLog` 来实现事务的：

1. InnoDB 在收到一个更新语句时，回先根据条件找到数据所在项，并将该也缓存在 Buffer Pool 中
2. 执行更新语句时，会改 Buffer Pool 中的数据，也就是内存中的数据
3. 针对更新语句生成一个 `RedoLog` 对象，并存入 `LogBuffer` 中
4. 针对更新语句生成 `UndoLog` 日志，用于事务回滚
5. 如果事务提交，那么就把 `RedoLog` 对象进行持久化，后续还有其他机制将 `Buffer Pool` 中修改的数据页持久化到磁盘中
6. 如果事务回滚，那么就利用 `UndoLog` 日志进行回滚





## 锁

**按锁粒度分类：**

1. 行锁：锁某行数据，粒度最小，并发度最高
2. 表锁：锁整张表，粒度最大，并发度最低
3. 间隙锁：锁住一个区间

**按读写分类：**

1. 共享锁（S 锁）：读锁，一个事务给某行数据加了读锁，那么其他事务还是能读但是不能写
2. 排他锁（X 锁）：写锁，一个事务给某行数据加了写锁，那么其他事务不能读也不能写

**还可以分为：**

1. 悲观锁：上述的锁都是悲观锁
2. 乐观锁：使用版本号等不会真正锁住某行数据的方式来实现

| 锁名称                                 | 解释                                                         | 隔离级别             | 使用场景                                           |
| -------------------------------------- | ------------------------------------------------------------ | -------------------- | -------------------------------------------------- |
| 共享锁（Shared Lock）                  | 允许读取并发操作，但阻止写操作                               | RR、RC、Serializable | 适用于读取操作较多的情况，如查询                   |
| 排他锁（Exclusive Lock）               | 阻止读取和写操作并发进行                                     | RR、RC、Serializable | 适用于写操作较多的情况，如更新、删除               |
| 意向共享锁（Intention Shared Lock）    | 表示事务将要在某个范围内加共享锁                             | 所有隔离级别         | 由数据库自动加上，一般不需要手动加锁               |
| 意向排他锁（Intention Exclusive Lock） | 表示事务将要在某个范围内加排他锁                             | 所有隔离级别         | 由数据库自动加上，一般不需要手动加锁               |
| 记录锁（Record Lock）                  | 锁定一条记录                                                 | RR、RC、Serializable | 适用于对某些记录进行加锁的场景                     |
| 间隙锁（Gap Lock）                     | 锁定记录之间的间隙，防止其他事务在这个范围内插入记录         | RR、RC、Serializable | 适用于防止其他事务在某个范围内插入记录的场景       |
| 临键锁（Next-Key Lock）                | 既锁定了记录之间的间隙，也锁定了记录本身，防止其他事务在这个范围内插入或修改记录 | RR、RC、Serializable | 适用于防止其他事务在某个范围内插入或修改记录的场景 |
| 行锁（Row Lock）                       | 锁定一行记录                                                 | RR、RC、Serializable | 适用于需要锁定单个记录的场景                       |
| 表锁（Table Lock）                     | 锁定整张表                                                   | 所有隔离级别         | 适用于需要全表操作的场景，如备份、数据导入等       |

==注意：==以上隔离级别指的是使用该锁时可以使用的隔离级别，但并不代表该锁只能在该隔离级别下使用，实际上大多数锁在所有隔离级别下都可以使用。





### 行锁和记录锁

在MySQL中，行锁和记录锁是两种不同的锁类型。它们的区别在于锁定的粒度不同。

1. 行锁：

   行锁是指在执行SQL语句时，对某一行记录进行的锁定。行锁的优点是粒度小，可以避免大面积的锁冲突，提高并发性能。MySQL中的InnoDB引擎支持行锁。

2. 记录锁：

   记录锁是指在执行SQL语句时，对某一个索引记录进行的锁定。记录锁的优点是锁定的范围更小，能够减少锁冲突，提高并发性能。MySQL中的MyISAM引擎支持记录锁。

需要注意的是，MySQL中的行锁和记录锁并不是严格区分的。如果对某一行记录进行锁定，也会同时对其对应的索引记录进行锁定，因为这两者是相关的。同时，在使用InnoDB引擎时，可以通过设置参数来控制行锁和记录锁的使用，以提高并发性能和数据一致性。





### 临键锁和间隙锁

> 临键锁相当于记录锁和间隙锁的组合

“临键”指的是记录之间的空隙（gap），因为临键锁实际上是锁定了记录之间的空隙。在执行一个查询语句时，如果MySQL需要对一个范围内的记录加锁，它会将这个范围分为若干个间隙，然后对这些间隙加锁。例如，对id在1到10之间的记录加锁时，MySQL会将这个范围分为10个间隙（1-2之间的间隙、2-3之间的间隙、3-4之间的间隙……9-10之间的间隙），然后对这些间隙加锁。

和临键锁类似的是间隙锁（Gap Lock），间隙锁也是锁定记录之间的间隙。不同的是，临键锁既锁定了记录之间的间隙，也锁定了记录本身；而间隙锁只锁定了记录之间的间隙，不锁定记录本身。举个例子，假设在一个表中id为1的记录被加了排他锁，这个时候如果有一个查询语句需要锁定id在1到10之间的记录，MySQL会先锁定id为1的记录，然后锁定id为2到10之间的间隙，这样其他事务就无法在这个范围内插入记录。如果使用的是临键锁，MySQL会将id为1到10之间的所有记录都锁定，包括id为1的记录和id为2到10之间的间隙。

由于临键锁和间隙锁都是锁定了记录之间的间隙，它们的作用和特点比较相似，容易混淆。区别在于临键锁除了锁定间隙，还锁定了记录本身，而间隙锁只锁定了间隙。因此，在使用这两种锁的时候，需要根据具体情况进行选择。例如，如果要防止其他事务在一个范围内插入记录，可以使用间隙锁；如果要防止其他事务在一个范围内插入或修改记录，可以使用临键锁。





### 其他

1. innodb对于行的查询使用next-key lock

2. Next-locking keying为了解决Phantom Problem幻读问题

3. 当查询的索引含有唯一属性时，将next-key lock降级为record key

4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生

5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） 
   1. 将事务隔离级别设置为RC
   2. 将参数innodb_locks_unsafe_for_binlog设置为1








## DQL语言（Data Query Language）

基础查询（注意：查询的表格是一个虚拟的表格） 
查询的列表可以是：  

1. 表中的字段  
2. 常量值  
3. 表达式  
4. 函数 

:::info 语法

select 查询列表  

from 查询的表名  

:::



### 查询表中的单个字段

```mysql
select 单个字段名 from 表名;  
```



### 查询表中的多个字段

```mysql
select 字段名,字段名,... from 表名;
```



### 查询表中的全部字段

```mysql
select * from 表名;
```



### 查询表中的常量

```mysql
select 常量;
```



### 查询表达式（表达式如：100*10）

```mysql
select 表达式;
```



### 查询函数

```mysql
select 函数名();
```



### 查询数据时起别名（便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来）

```mysql
1、select 表达式 as 别名, 表达式 as 别名,... from 表名;
2、select 表达式 别名, 表达式 别名,... from 表名;
```



### 去除重复的数据

```mysql
select distinct 字段 from 表名;
```



### mysql中的+只是运算符，字段拼接则需要：

```mysql
select concat(字段，字段，字段) as 结果 from 表名;
```



### 判断是否为null，如果是则给出其他结果

```mysql
select ifnull(可能为空的字段,希望的输出的结果) as 字段的别名 （可加原来的字段做对比） from 表名;
```





:::info 语法 

select 查询列表 from 表名 where 筛选条件;  

:::

  

:::info 分类

分类： 

1. 按条件表达式筛选:  
2. 条件运算符：`> < = （不等于）<> >= <= （安全等于）<=>`
3. 按逻辑表达式筛选  
4. 逻辑运算符：`（&& || ! ） 标准的是：and or not`  
5. 模糊查询，涉及的关键词：`like (between and) in (is null)`  
   1. 通配符：  
   2. `%` 代表任意多个字符（包含0个字符）  
   3. `_` 代表任意单个字符  
   4. 转义符可以为：`\`  或者指定任意字符为转义符（以指定 `#` 为转义符为例），语法：... like '任意通配符#任意通配符' escape '#';  

:::



### 按条件表达式筛选

```mysql
select 查询列表 from 表名 where 条件表达式语句（包含但不全有：`> < = <> >= <= <=>`）;
```



### 按逻辑表达式子

```mysql
select 查询列表 from 表名 where 逻辑表达式语句（包含但不全有：`and or not > < = <> >= <= <=>`）;
```



### 模糊查询（%为通配符；注意：like后的模糊匹配字符必须用单引号）

```mysql
（1）like（一般和通配符一起使用）：  
    select 查询列表 from 表名 where 字段名 like '%包含的字符%'（用通配符筛选出字段应该包含的内容）;  
（2）between .. and .. （包含临界值，相当于：字段名>=条件1 and 字段名<=条件2）：  
    select 查询列表 from 表名 where 字段名 between 条件 and 条件;  
（3）in（注意：不支持通配符，且相当于：字段名=字段1 or 字段名=字段2 or ...）：  
     select 查询列表 from 表名 where 字段名 in(字段,字段,...);  
（4）is null：  
    select 查询列表 from 表名 where 字段名 is （not） null;  
    注：用`<=>`表示判断是否等于（既可以判断null又可以判断具体的值，但可读性较差），返回true或false，如：  
    select 查询列表 from 表名 where 字段名 `<=>` 值;
```









## DML语言（Data Manipulation Language）









## DDL语言（Data Define Language）









## TCL语言（Transaction Control Language）





