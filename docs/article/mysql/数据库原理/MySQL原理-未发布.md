---
title: "MySQL 原理"
shortTitle: "MySQL 原理"
description: "MySQL 原理"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2021-05-11
category: 
- "mysql"
- "数据库"
tag:
- "mysql"
- "数据库"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "MySQL 原理"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "MySQL 原理"
  description: "MySQL 原理"
  author:
    name: gzw
    email: 1627121193@qq.com
---


# MySQL 原理



# day 1

## 工作原理

1. MySQL 是使用 C 写的

2. 对于数据库而言，重要的不是数据量，而是当数据量增加时运算如何增加

3. MySQL 中的 sort 使用的是「归并排序」

4. 二叉搜索树是查询的关键，MySQL 中使用的是 B+ 树（索引）：

   ​	查找一个特定值这个树挺好用，但是当你需要**查找两个值之间的多个元素**时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法

5. 数据库一般需要：
   1. 核心组件
   2. 管理工具
   3. 查询管理器
      - 查询解析器：检查语法、语序、权限是否正确
      - 查询重写器：预优化查询、避免不必要的运算、帮助优化器找到合理的最佳方案
      - 统计：避免浪费资源
      - 查询优化器：所有的现代数据库都在用**基于成本的优化**（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法
      - 查询执行器
   4. 数据管理器
      - 缓存管理器：避免 I/O 瓶颈，还会进行预读，多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法作为缓冲区置换策略
      - 事务管理器
      - 并发控制
      - 锁管理器
      - 日志管理器



大多时候瓶颈都在于磁盘 I/O 而不是 CPU

仅供参考：还有其他类型的索引，比如位图索引，在 CPU、磁盘I/O、和内存方面与B+树索引的成本并不相同。

另外，很多现代数据库为了改善执行计划的成本，可以仅为当前查询动态地生成临时索引。



数据库的扫描方式：

1. 全表扫描
2. 范围扫描
3. 唯一扫描
4. 根据 ROW ID 存取



常用的联接操作：

> **联接的类型**：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。

1. 嵌套循环联接（大表联接小表较快，如果两表都大那么 CPU 成本较高）
2. 哈希连接（需要较大内存）
3. 合并联接（唯一产生排序的联接，如果结果需要排序或者有索引的话就是很好的选择）



算法：

对于小规模的查询，采取粗暴的方式是有可能的。但是为了让中等规模的查询也能采取粗暴的方式，我们有办法避免不必要的计算，这就是动态规划

优化器面对一个非常大的查询，或者为了尽快找到答案（然而查询速度就快不起来了），会应用另一种算法，叫贪婪算法



查询计划缓存：

由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除



查询执行：

在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器





## 数据库设计流程

1. **需求分析**：分析用户的需求，包括数据、功能和性能需求；
2. **概念结构设计**：主要采用E-R模型进行设计，包括画E-R图；
3. **逻辑结构设计**：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
4. **数据库物理设计**：主要是为所设计的数据库选择合适的存储结构和存取路径；
5. **数据库的实施**：包括编程、测试和试运行；
6. **数据库运行与维护**：系统的运行与数据库的日常维护





## 核心知识点

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交

封锁粒度：MySQL 中提供了两种封锁粒度: 行级锁以及表级锁

封锁类型：

- 读写锁：排他锁（X 锁，写锁）；共享锁（S 锁，读锁）
- 意向锁：在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定

规定：

一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁

一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁

一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁

一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁

任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁

S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁

封锁协议：

1. 三级封锁协议
2. 两段锁协议

隐式与显示锁定（MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定），可以通过特定语句进行显示锁定





## SQL 优化

- 负向查询不能使用索引
- 前导模糊查询不能使用索引（建议可以考虑使用 `Lucene` 等全文索引工具来代替频繁的模糊查询）
- 数据区分不明显的不建议创建索引
- 字段的默认值不要为 null
- 在字段上进行计算是不能命中索引的
- 复合索引的最左前缀单独使用才可以命中索引（全部使用也可以）
- 如果明确最终只有一条记录返回，可以在查询语句最后加上 `limit 1`，可以提高效率，可以让数据库停止游标移动
- 数据库层面做类型转换可能会导致全表扫描，查询时一定要使用正确的类型
- 进行 join 的字段，两表中的字段类型不相同是不会命中索引的



# day 2