import{_ as l,Q as i,S as e,a5 as a}from"./framework-ec2af7a3.js";const r={},o=a('<h1 id="mysql-原理" tabindex="-1"><a class="header-anchor" href="#mysql-原理" aria-hidden="true">#</a> MySQL 原理</h1><h1 id="day-1" tabindex="-1"><a class="header-anchor" href="#day-1" aria-hidden="true">#</a> day 1</h1><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><ol><li><p>MySQL 是使用 C 写的</p></li><li><p>对于数据库而言，重要的不是数据量，而是当数据量增加时运算如何增加</p></li><li><p>MySQL 中的 sort 使用的是「归并排序」</p></li><li><p>二叉搜索树是查询的关键，MySQL 中使用的是 B+ 树（索引）：</p><p>​ 查找一个特定值这个树挺好用，但是当你需要<strong>查找两个值之间的多个元素</strong>时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法</p></li><li><p>数据库一般需要：</p><ol><li>核心组件</li><li>管理工具</li><li>查询管理器 <ul><li>查询解析器：检查语法、语序、权限是否正确</li><li>查询重写器：预优化查询、避免不必要的运算、帮助优化器找到合理的最佳方案</li><li>统计：避免浪费资源</li><li>查询优化器：所有的现代数据库都在用<strong>基于成本的优化</strong>（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法</li><li>查询执行器</li></ul></li><li>数据管理器 <ul><li>缓存管理器：避免 I/O 瓶颈，还会进行预读，多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法作为缓冲区置换策略</li><li>事务管理器</li><li>并发控制</li><li>锁管理器</li><li>日志管理器</li></ul></li></ol></li></ol><p>大多时候瓶颈都在于磁盘 I/O 而不是 CPU</p><p>仅供参考：还有其他类型的索引，比如位图索引，在 CPU、磁盘I/O、和内存方面与B+树索引的成本并不相同。</p><p>另外，很多现代数据库为了改善执行计划的成本，可以仅为当前查询动态地生成临时索引。</p><p>数据库的扫描方式：</p><ol><li>全表扫描</li><li>范围扫描</li><li>唯一扫描</li><li>根据 ROW ID 存取</li></ol><p>常用的联接操作：</p><blockquote><p><strong>联接的类型</strong>：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。</p></blockquote><ol><li>嵌套循环联接（大表联接小表较快，如果两表都大那么 CPU 成本较高）</li><li>哈希连接（需要较大内存）</li><li>合并联接（唯一产生排序的联接，如果结果需要排序或者有索引的话就是很好的选择）</li></ol><p>算法：</p><p>对于小规模的查询，采取粗暴的方式是有可能的。但是为了让中等规模的查询也能采取粗暴的方式，我们有办法避免不必要的计算，这就是动态规划</p><p>优化器面对一个非常大的查询，或者为了尽快找到答案（然而查询速度就快不起来了），会应用另一种算法，叫贪婪算法</p><p>查询计划缓存：</p><p>由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除</p><p>查询执行：</p><p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器</p><h2 id="数据库设计流程" tabindex="-1"><a class="header-anchor" href="#数据库设计流程" aria-hidden="true">#</a> 数据库设计流程</h2><ol><li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；</li><li><strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括画E-R图；</li><li><strong>逻辑结构设计</strong>：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；</li><li><strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；</li><li><strong>数据库的实施</strong>：包括编程、测试和试运行；</li><li><strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护</li></ol><h2 id="核心知识点" tabindex="-1"><a class="header-anchor" href="#核心知识点" aria-hidden="true">#</a> 核心知识点</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交</p><p>封锁粒度：MySQL 中提供了两种封锁粒度: 行级锁以及表级锁</p><p>封锁类型：</p><ul><li>读写锁：排他锁（X 锁，写锁）；共享锁（S 锁，读锁）</li><li>意向锁：在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定</li></ul><p>规定：</p><p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁</p><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</p><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</p><p>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</p><p>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁</p><p>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁</p><p>封锁协议：</p><ol><li>三级封锁协议</li><li>两段锁协议</li></ol><p>隐式与显示锁定（MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定），可以通过特定语句进行显示锁定</p><h2 id="sql-优化" tabindex="-1"><a class="header-anchor" href="#sql-优化" aria-hidden="true">#</a> SQL 优化</h2><ul><li>负向查询不能使用索引</li><li>前导模糊查询不能使用索引（建议可以考虑使用 <code>Lucene</code> 等全文索引工具来代替频繁的模糊查询）</li><li>数据区分不明显的不建议创建索引</li><li>字段的默认值不要为 null</li><li>在字段上进行计算是不能命中索引的</li><li>复合索引的最左前缀单独使用才可以命中索引（全部使用也可以）</li><li>如果明确最终只有一条记录返回，可以在查询语句最后加上 <code>limit 1</code>，可以提高效率，可以让数据库停止游标移动</li><li>数据库层面做类型转换可能会导致全表扫描，查询时一定要使用正确的类型</li><li>进行 join 的字段，两表中的字段类型不相同是不会命中索引的</li></ul><h1 id="day-2" tabindex="-1"><a class="header-anchor" href="#day-2" aria-hidden="true">#</a> day 2</h1>',39),p=[o];function t(n,d){return i(),e("div",null,p)}const h=l(r,[["render",t],["__file","MySQL原理-未发布.html.vue"]]);export{h as default};
