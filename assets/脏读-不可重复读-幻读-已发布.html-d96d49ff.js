import{_ as t,Q as i,S as d,a5 as l}from"./framework-ec2af7a3.js";const r={},_=l('<h1 id="脏读-不可重复读-幻读" tabindex="-1"><a class="header-anchor" href="#脏读-不可重复读-幻读" aria-hidden="true">#</a> 脏读/不可重复读/幻读</h1><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不能重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>REPEATABLE READ</td><td>否</td><td>否</td><td>是（innodb 除外）</td><td>否</td></tr><tr><td>SERIALIZABLE</td><td>否</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li><p>脏读：</p><ul><li>事务读取到其他事务没提交的数据（针对某个字段）</li></ul></li><li><p>不可重复读：</p><ul><li>指同一次事务中前后查询不一致的问题（针对某个字段）</li><li>即在并发更新时，另一个事务前后查询相同数据时不符合预期</li></ul></li><li><p>幻读：</p><ul><li>一次事务中前后数据量发生变化（针对某几行数据）</li><li>即在并发新增、删除这种会产生数量变化的操作时，另一个事务亲啊后查询相同数据时不符合预期</li></ul></li></ul><p><strong>PR 级别解决幻读问题：</strong></p><p>MySQL 5.1 以上默认使用 innodb，事务隔离级别为可重复读（REPEATABLE READ），但是由于 MVCC（Multi-Version Concurrency Control，多版本并发控制方案），这里的可重复读也可以解决幻读的问题；MVCC 核心为 UNDO_LOG 版本链和 ReadView 快照读（见下文的补充）</p><ul><li><p>UNDO_LOG 版本链使用链表的形式维护数据的历史版本，用于回滚，MySQL 在确保版本链数据不在被引用后才将其删除</p></li><li><p>ReadView 快照读是 SQL 执行时 MVCC 提取数据的依据；</p></li><li><p>【快照读】就是最普通的 Select 查询的 SQL 语句：【当前读】指代写操作对应的 SQL 语句，这时会加上写锁；只有【快照读】才会使用 MVCC，【当前读】会使用行锁与间隙锁</p></li><li><p>当使用 MVCC 时会访问 UNDO_LOG，根据 ReadView 中的数据与访问规则查找 UNDO_LOG 中的数据</p></li><li><p>但是其实 PR 级别下使用 MVCC 不能完全保证消除幻读</p><ul><li>当连续产生多次快照时，ReadView 会产生复用，没有幻读的问题</li><li>当两次快照之间存在【当前读】，ReadView 会重新生成，此时可能产生幻读</li></ul></li></ul><h1 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h1><p><strong>UNDO_LOG 版本链的节点的数据结构包含四个字段：</strong></p><ul><li>id：标识</li><li>字段名：当前数据对应的字段名</li><li>trx_id：对应 ReadView 中的 trx_id</li><li>db_roll_ptr： next 指针</li></ul><p><strong>ReadView 的数据结构包含四个字段：</strong></p><ul><li><p>m_ids：当前活跃的事务编号集合，即还没有被提交的事务</p></li><li><p>min_trx_id：最小活跃事务编号</p></li><li><p>max_trx_id：预分配事务编号，当前最大事务编号 + 1</p></li><li><p>creator_trx_id： ReadView 创建者的事务编号</p></li></ul><p><strong>UNDO_LOG 版本链的访问规则：</strong></p><ul><li>当前事务 trx_id 等于 creator_trx_id 时，说明这个数据是自己修改的，可以访问</li><li>当 trx_id 小于 min_trx_id 时，说明数据已经提交，可以访问</li><li>当 trx_id 大于 max_trx_id时，说明该事务是 ReadView 生成之后才开启的，不允许访问</li><li>当 min_trx_id &lt;= trx_id &lt;= max_trx_id 时，与 m_ids 中的事务比对，当 trx_id 不在m_ids 中时说明 trx_id 对应的已经提交，可以访问</li></ul>',13),e=[_];function a(n,p){return i(),d("div",null,e)}const s=t(r,[["render",a],["__file","脏读-不可重复读-幻读-已发布.html.vue"]]);export{s as default};
